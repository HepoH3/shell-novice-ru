---
title: Скрипты оболочки
teaching: 30
exercises: 15
---

::::::::::::::::::::::::::::::::::::::: objectives

- Написать скрипт оболочки, который запускает одну или несколько команд для фиксированного набора файлов.
- Запустить скрипт оболочки из командной строки.
- Написать скрипт оболочки, который работает с набором файлов, определяемым пользователем на командной строке.
- Создать конвейеры, включающие скрипты оболочки, написанные вами или другими.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Как можно сохранить и повторно использовать команды?

::::::::::::::::::::::::::::::::::::::::::::::::::

Наконец, мы готовы увидеть, что делает оболочку настолько мощной средой программирования. Мы собираемся взять команды, которые мы часто повторяем, и сохранить их в файлах, чтобы затем снова запустить все эти операции, набрав одну единственную команду. Исторически сложилось, что набор команд, сохранённых в файле, называется **скриптом оболочки**, но не заблуждайтесь — это настоящие небольшие программы.

Запись скриптов оболочки сделает вашу работу не только быстрее, но и избавит вас от необходимости повторно вводить те же команды. Это также сделает её более точной (меньше шансов на опечатки) и более воспроизводимой. Если вы вернётесь к своей работе позже (или кто-то другой найдёт вашу работу и захочет её использовать), вы сможете воспроизвести те же результаты, просто запустив свой скрипт, а не вспоминая или заново вводя длинный список команд.

Давайте начнём с возвращения в директорию `alkanes/` и создания нового файла, `middle.sh`, который станет нашим скриптом оболочки:


```bash
$ cd alkanes
$ nano middle.sh
```

Команда `nano middle.sh` откроет файл `middle.sh` в текстовом редакторе `nano` (который работает внутри оболочки). Если файла не существует, он будет создан. Мы можем использовать текстовый редактор для прямого редактирования файла, добавив следующую строку:

```source
head -n 15 octane.pdb | tail -n 5
```

Это вариация на тему конвейера, который мы уже создавали ранее. Он выбирает строки с 11 по 15 из файла `octane.pdb`. Помните, что мы пока не запускаем эту команду; мы просто сохраняем её в файл.

Затем мы сохраняем файл (`Ctrl-O` в `nano`) и выходим из текстового редактора (`Ctrl-X` в `nano`). Проверьте, что в директории `alkanes` теперь есть файл под названием `middle.sh`.

Как только файл сохранён, мы можем попросить оболочку выполнить команды, которые он содержит. Наша оболочка называется `bash`, поэтому мы выполняем следующую команду:

```bash
$ bash middle.sh
```

```output
ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00
```

И действительно, вывод нашего скрипта точно такой же, как если бы мы запустили этот конвейер напрямую.

:::::::::::::::::::::::::::::::::::::::::  callout

## Текст против чего-то другого

Мы часто называем некоторые программы, такие как Microsoft Word или LibreOffice Writer, "текстовыми редакторами", но нам нужно быть осторожнее со словами, когда дело доходит до программирования. По умолчанию Microsoft Word использует файлы `.docx`, которые сохраняют не только текст, но и информацию о форматировании (шрифты, заголовки и т. д.). Эта дополнительная информация не хранится в виде символов и не имеет смысла для таких инструментов, как `head`, который ожидает, что входные файлы будут содержать только буквы, цифры и знаки препинания с обычной клавиатуры. Поэтому при редактировании программ нужно либо использовать редактор для работы с обычным текстом, либо сохранять файлы как простой текст.

::::::::::::::::::::::::::::::::::::::::::::::::::

Что если мы захотим выбирать строки из произвольного файла? Мы могли бы каждый раз редактировать `middle.sh`, изменять там имя файла, но это, вероятно, займёт больше времени, чем просто ввести команду снова и выполнить её с новым именем файла. Вместо этого давайте отредактируем `middle.sh` так, чтобы сделать его более универсальным:

```bash
$ nano middle.sh
```

Теперь в `nano` заменим текст `octane.pdb` на специальную переменную $1:

```source
head -n 15 "$1" | tail -n 5
```

Внутри скрипта оболочки `$1` означает 'первый аргумент, поданной из командной строки'. Теперь мы можем запустить наш скрипт вот так:

```bash
$ bash middle.sh octane.pdb
```

```output
ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00
```

а для другого файла вот так:

```bash
$ bash middle.sh pentane.pdb
```

```output
ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00
ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00
ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00
ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00
ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Двойные кавычки вокруг аргументов

По той же причине, почему мы использовали переменные цикла в двойных кавычках, в случае если имя файла содержит пробелы, мы используем двойные кавычки и вокруг переменной `$1`.

::::::::::::::::::::::::::::::::::::::::::::::::::

На данный момент нам нужно редактировать `middle.sh` каждый раз, когда мы хотим изменить диапазон строк, которые возвращаются. Давайте исправим это, настроив наш скрипт так, чтобы он использовал три аргумента командной строки. После первого аргумента командной строки (`$1`), каждый следующий аргумент будет доступен через специальные переменные `$1`, `$2`, `$3`, которые ссылаются на первый, второй, третий аргумент командной строки соответственно.

Зная это, мы можем использовать дополнительные аргументы для задания диапазона строк, которые будут переданы в `head` и `tail`:

```bash
$ nano middle.sh
```

```source
head -n "$2" "$1" | tail -n "$3"
```

Теперь можно выполнить:

```bash
$ bash middle.sh pentane.pdb 15 5
```

```output
ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00
ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00
ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00
ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00
ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00
```

Изменяя аргументы в команде, мы можем менять поведение нашего скрипта:

```bash
$ bash middle.sh pentane.pdb 20 5
```

```output
ATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00
ATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00
ATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00
ATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00
TER      18              1
```

Это работает, но следующий человек, который откроет `middle.sh`, может не сразу понять, что он делает. Мы можем улучшить скрипт, добавив несколько **комментариев** в начале:

```bash
$ nano middle.sh
```

```source
# Выбор строк из середины файла.
# Использование: bash middle.sh имя_файла номер_последней_строки количество_строк
head -n "$2" "$1" | tail -n "$3"
```

Комментарий начинается с символа `#` и продолжается до конца строки. Компьютер игнорирует комментарии, но они бесценны для того, чтобы помочь людям (включая вас в будущем) понять и использовать скрипты. Единственное предостережение: каждый раз, когда вы модифицируете скрипт, нужно проверить, чтобы комментарий оставался точным. Объяснение, которое уводит читателя в неправильном направлении, хуже, чем его отсутствие.

Что, если мы хотим обработать несколько файлов в одном конвейере? Например, если мы хотим отсортировать наши `.pdb` файлы по длине, мы бы набрали:

```bash
$ wc -l *.pdb | sort -n
```

потому что `wc -l` выводит количество строк в файлах (напомним, что `wc` означает 'подсчёт слов', добавление опции `-l` означает 'подсчёт строк') и `sort -n` сортирует всё в числовом порядке. Мы могли бы поместить это в файл, но тогда он будет работать только с `.pdb` файлами в текущей директории. Если мы хотим получить отсортированный список других типов файлов, нам нужно передать их имена в скрипт. Мы не можем использовать `$1`, `$2` и так далее, потому что не знаем, сколько файлов будет. Вместо этого мы используем специальную переменную `$@`, которая означает 'все аргументы командной строки для скрипта оболочки'. Мы также должны заключить `$@` в двойные кавычки чтобы обрабатывать случаи, когда в аргументах есть пробелы ("$@" — это специальный синтаксис, эквивалентный "$1" "$2" ...).

Вот пример:

```bash
$ nano sorted.sh
```

```source
# Сортировка файлов по их длине.
# Использование: bash sorted.sh одно_или_несколько_имён_файлов
wc -l "$@" | sort -n
```

```bash
$ bash sorted.sh *.pdb ../creatures/*.dat
```

```output
9 methane.pdb
12 ethane.pdb
15 propane.pdb
20 cubane.pdb
21 pentane.pdb
30 octane.pdb
163 ../creatures/basilisk.dat
163 ../creatures/minotaur.dat
163 ../creatures/unicorn.dat
596 total
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Список уникальных видов

У Лии есть несколько сотен файлов с данными, каждый из которых выглядит так:

```source
2013-11-05,deer,5
2013-11-05,rabbit,22
2013-11-05,raccoon,7
2013-11-06,rabbit,19
2013-11-06,deer,2
2013-11-06,fox,1
2013-11-07,rabbit,18
2013-11-07,bear,1
```

Пример такого типа файла находится в `shell-lesson-data/exercise-data/animal-counts/animals.csv`.

Мы можем использовать команду `cut -d , -f 2 animals.csv | sort | uniq`, чтобы вывести уникальные виды в файле `animals.csv`. Чтобы не вводить эту команду каждый раз, учёная может написать скрипт оболочки.

Напишите скрипт оболочки под названием `species.sh`, который принимает любое количество имён файлов в качестве аргументов командной строки и использует вариант этой команды для вывода списка уникальных видов, встречающихся в каждом из файлов отдельно.

:::::::::::::::  solution

## Решение

```bash
# Скрипт для поиска уникальных видов в файлах CSV, где виды находятся во втором
# столбце
# Этот скрипт принимает любое количество имён файлов в качестве аргументов
# командной строки

# Проход по всем файлам
for file in $@
do
    echo "Unique species in $file:"
    # Извлечение названий видов
    cut -d , -f 2 $file | sort | uniq
done
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Предположим, что мы только что выполнили серию команд, которые сделали что-то полезное — например, создали график, который мы хотели бы использовать в статье. Мы хотим иметь возможность воссоздать этот график позже, если потребуется, поэтому хотим сохранить команды в файл. Вместо того чтобы набирать их снова (и, возможно, ошибаться), мы можем сделать так:

```bash
$ history | tail -n 5 > redo-figure-3.sh
```

Теперь файл `redo-figure-3.sh` содержит:

```source
297 bash goostats.sh NENE01729B.txt stats-NENE01729B.txt
298 bash goodiff.sh stats-NENE01729B.txt /data/validated/01729.txt > 01729-differences.txt
299 cut -d ',' -f 2-3 01729-differences.txt > 01729-time-series.txt
300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png
301 history | tail -n 5 > redo-figure-3.sh
```

Потратив минуту в редакторе, чтобы убрать порядковые номера команд и удалить последнюю строку, где была вызвана команда `history`, мы получаем точную запись того, как был создан этот график.

:::::::::::::::::::::::::::::::::::::::  challenge

## Зачем записывать команды в историю перед их выполнением?

Если вы выполните команду:

```bash
$ history | tail -n 5 > recent.sh
```

последняя команда в файле будет командой `history`, т.е. оболочка добавила команду `history` в журнал команд до фактического её выполнения. На самом деле, оболочка всегда добавляет команды в журнал перед их выполнением. Как вы думаете, зачем она это делает?

:::::::::::::::  solution

## Решение

Если команда вызывает сбой или зависание, может быть полезно узнать, что это была за команда, чтобы расследовать проблему. Если бы команда записывалась в журнал только после её выполнения, мы бы не имели записи о последней выполненной команде в случае сбоя.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

На практике большинство людей создают скрипты оболочки, выполняя команды в командной строке несколько раз, чтобы убедиться, что они работают правильно, а затем сохраняют их в файл для повторного использования. Такой стиль работы позволяет людям повторно использовать то, что они узнали о своих данных и рабочем процессе, с одной командой `history` и небольшим редактированием, чтобы очистить вывод и сохранить его как скрипт оболочки.

## Конвейер Нелли: Создание скрипта

Руководитель Нелли настаивает на том, что вся её аналитика должна быть воспроизводимой. Самый простой способ зафиксировать все шаги — это записать их в скрипт.

Сначала мы возвращаемся в проектную директорию Нелли:

```bash
$ cd ../../north-pacific-gyre/
```

Она создаёт файл, используя `nano` ...

```bash
$ nano do-stats.sh
```

...в который она записывает следующее:

```bash
# Рассчитать статистику для файлов данных.
for datafile in "$@"
do
    echo $datafile
    bash goostats.sh $datafile stats-$datafile
done
```

Она сохраняет этот файл под именем `do-stats.sh`, чтобы теперь можно было повторно выполнить первый этап её анализа, набрав:

```bash
$ bash do-stats.sh NENE*A.txt NENE*B.txt
```

Она также может выполнить:

```bash
$ bash do-stats.sh NENE*A.txt NENE*B.txt | wc -l
```

чтобы вывести только количество обработанных файлов, а не имена обработанных файлов.

Одно из достоинств скрипта Нелли состоит в том, что он позволяет пользователю решить, какие файлы обрабатывать. Она могла бы написать его так:

```bash
# Рассчитать статистику для файлов данных по типам A и B.
for datafile in NENE*A.txt NENE*B.txt
do
    echo $datafile
    bash goostats.sh $datafile stats-$datafile
done
```

Преимущество такого подхода в том, что он всегда выбирает правильные файлы: ей не нужно помнить об исключении файлов с буквой 'Z'. Недостаток же в том, что он всегда выбирает только эти файлы — она не сможет запустить его на всех файлах (включая файлы с буквой 'Z'), или на файлах с буквами 'G' или 'H', которые её коллеги из Антарктиды производят, без редактирования скрипта. Если бы она хотела более гибкий вариант, она могла бы изменить свой скрипт так, чтобы он проверял наличие аргументов командной строки, и использовал бы `NENE*A.txt NENE*B.txt`, если аргументы не указаны. Конечно, это вводит новый компромисс между гибкостью и сложностью.

:::::::::::::::::::::::::::::::::::::::  challenge

## Переменные в скриптах оболочки

В директории `alkanes` представьте, что у вас есть скрипт под названием `script.sh`, который содержит следующие команды:

```bash
head -n $2 $1
tail -n $3 $1
```

Находясь в директории `alkanes`, вы набираете следующую команду:

```bash
$ bash script.sh '*.pdb' 1 1
```

Какой из следующих выводов вы ожидаете увидеть?

1. Все строки между первой и последней строками каждого файла с расширением `.pdb` в директории `alkanes`
2. Первая и последняя строки каждого файла с расширением `.pdb` в директории `alkanes`
3. Первая и последняя строки каждого файла в директории `alkanes`
4. Ошибка из-за кавычек вокруг `*.pdb`

:::::::::::::::  solution

## Решение

Правильный ответ — 2.

Специальные переменные `$1`, `$2` и `$3` представляют аргументы командной строки, переданные скрипту, таким образом, команды, которые выполняются, будут следующими:

```bash
$ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb
$ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb
```

Оболочка не расширяет `'*.pdb'`, так как он заключён в кавычки. Таким образом, первый аргумент скрипта — это `'*.pdb'`, который будет расширен внутри скрипта перед вызовом команд `head` и `tail`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Найдите самый длинный файл с заданным расширением

Напишите скрипт оболочки под названием `longest.sh`, который принимает в качестве аргументов имя директории и расширение файлов и выводит имя файла с наибольшим количеством строк в этой директории с указанным расширением. Например:

```bash
$ bash longest.sh shell-lesson-data/exercise-data/alkanes pdb
```

выведет имя файла с расширением `.pdb` в директории `shell-lesson-data/exercise-data/alkanes`, который содержит наибольшее количество строк.

Не стесняйтесь протестировать свой скрипт на другой директории, например:

```bash
$ bash longest.sh shell-lesson-data/exercise-data/writing txt
```

:::::::::::::::  solution

## Решение

```bash
# Скрипт, который принимает два аргумента:
#    1. имя директории
#    2. расширение файлов
# и выводит имя файла, который:
#    1. находится в указанной директории,
#    2. имеет указанное расширение,
#    3. содержит наибольшее количество строк.
# .

wc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1
```

Первая часть конвейера, `wc -l $1/*.$2 | sort -n`, подсчитывает количество строк в каждом файле и сортирует их численно (от меньшего к большему). Когда файлов несколько, `wc` также выводит итоговую строку, показывающую общее количество строк по всем файлам. Мы используем `tail -n 2 | head -n 1`, чтобы отбросить эту последнюю строку.

При использовании команды `wc -l $1/*.$2 | sort -n | tail -n 1` будет отображена итоговая строка: мы можем строить наш конвейер по частям, чтобы лучше понять его вывод.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Понимание скриптов

Для этого задания рассмотрите директорию `shell-lesson-data/exercise-data/alkanes`. Она содержит несколько файлов с расширением `.pdb`, а также другие файлы, которые вы могли создать. Объясните, что делает каждый из трёх скриптов при запуске как `bash script1.sh *.pdb`, `bash script2.sh *.pdb` и `bash script3.sh *.pdb` соответственно.

```bash
# Скрипт 1
echo *.*
```

```bash
# Скрипт 2
for filename in $1 $2 $3
do
    cat $filename
done
```

```bash
# Скрипт 3
echo $@.pdb
```

:::::::::::::::  solution

## Решение

В каждом случае оболочка расширяет подстановочный знак в `*.pdb` до того, как передаёт результат в качестве аргументов скрипту.

Скрипт 1 выведет список всех файлов, содержащих точку в своём имени. Переданные аргументы в скрипте нигде не используются.

Скрипт 2 выведет содержимое первых 3 файлов с расширением `.pdb`. `$1`, `$2` и `$3` относятся к первому, второму и третьему аргументам соответственно.

Скрипт 3 выведет все аргументы скрипта (т.е. все файлы с расширением `.pdb`), а затем добавит `.pdb` к каждому из них. `$@` относится ко всем аргументам, переданным в скрипт оболочки.

```output
cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Отладка скриптов

Предположим, вы сохранили следующий скрипт в файле под названием `do-errors.sh` в директории Нелли `north-pacific-gyre`:

```bash
# Рассчитать статистику для файлов данных.
for datafile in "$@"
do
    echo $datfile
    bash goostats.sh $datafile stats-$datafile
done
```

Когда вы запускаете его из директории `north-pacific-gyre`:

```bash
$ bash do-errors.sh NENE*A.txt NENE*B.txt
```

вывод окажется пустым. Чтобы выяснить причину, запустите скрипт с опцией -x:

```bash
$ bash -x do-errors.sh NENE*A.txt NENE*B.txt
```

Что показывает вывод? Какая строка отвечает за ошибку?

:::::::::::::::  solution

## Решение

Опция `-x` заставляет `bash` работать в режиме отладки. Она выводит каждую команду по мере её выполнения, что поможет найти ошибки. В данном примере мы видим, что команда `echo` ничего не выводит. Мы допустили опечатку в названии переменной в цикле, и переменная `datfile` не существует, поэтому возвращается пустая строка.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- Сохраняйте команды в файлах (обычно называемых shell-скриптами) для повторного использования.
- Команда `bash [имя_файла]` выполняет команды, сохранённые в файле.
- Переменная `$@` ссылается на все аргументы командной строки для shell-скрипта.
- Переменные `$1`, `$2` и т.д. ссылаются на первый, второй и последующие аргументы командной строки соответственно.
- Заключайте переменные в кавычки, если их значения могут содержать пробелы.
- Предоставление пользователям возможности выбирать файлы для обработки делает скрипты более гибкими и согласуется с встроенными командами Unix.

::::::::::::::::::::::::::::::::::::::::::::::::::
