---
title: Каналы и фильтры
teaching: 25
exercises: 10
---

::::::::::::::::::::::::::::::::::::::: objectives

- Объяснить преимущество связывания команд с помощью каналов (pipes) и фильтров.
- Комбинировать последовательности команд для получения нового вывода.
- Перенаправлять вывод команды в файл.
- Объяснить, что обычно происходит, если программа или конвейер не получают входных данных для обработки.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Как я могу комбинировать существующие команды для получения нужного результата?
- Как я могу показать только часть вывода?

::::::::::::::::::::::::::::::::::::::::::::::::::

Теперь, когда мы знаем несколько базовых команд, мы можем наконец-то рассмотреть одну из самых мощных возможностей оболочки: простоту, с которой она позволяет комбинировать существующие программы новыми способами. Мы начнём с каталога `shell-lesson-data/exercise-data/alkanes`, который содержит шесть файлов, описывающих простые органические молекулы. Расширение `.pdb` указывает на то, что эти файлы находятся в формате Protein Data Bank, простом текстовом формате, который указывает тип и положение каждого атома в молекуле.

```bash
$ ls
```

```вывод
cubane.pdb    methane.pdb    pentane.pdb
ethane.pdb    octane.pdb     propane.pdb
```

Запустим пример команды:

```bash
$ wc cubane.pdb
```

```вывод
20  156 1158 cubane.pdb
```

wc — это команда "word count" (подсчёт слов): она считает количество строк, слов и символов в файлах (возвращая значения в таком порядке слева направо).

Если мы запустим команду `wc *.pdb`, `*` в `*.pdb` заменяется на ноль или более символов, поэтому оболочка преобразует `*.pdb` в список всех файлов с расширением `.pdb` в текущем каталоге:

```bash
$ wc *.pdb
```

```вывод
  20  156  1158  cubane.pdb
  12  84   622   ethane.pdb
   9  57   422   methane.pdb
  30  246  1828  octane.pdb
  21  165  1226  pentane.pdb
  15  111  825   propane.pdb
 107  819  6081  total
```

Обратите внимание, что `wc *.pdb` также показывает общее количество строк в последней строке вывода.

Если мы запустим `wc -l` вместо обычного `wc`, то вывод покажет только количество строк на файл:

```bash
$ wc -l *.pdb
```

```вывод
  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total
```

С командой `wc` можно также использовать опции `-m` и `-w`, чтобы показать только количество символов или слов соответственно.

:::::::::::::::::::::::::::::::::::::::::  callout

## Почему команда ничего не делает?

Что произойдёт, если команда должна обработать файл, но мы не укажем имя файла? Например, что будет, если мы наберём:

```bash
$ wc -l
```

но не укажем `*.pdb` (или что-то ещё) после команды? Поскольку файлы не указаны, `wc` предполагает, что нужно обрабатывать ввод, предоставленный непосредственно в командной строке, поэтому она просто ждёт, пока мы не дадим ей какие-либо данные интерактивно. Со стороны может показаться, что команда просто зависла и ничего не делает.

Если вы совершите такую ошибку, вы можете выйти из этого состояния, удерживая клавишу <kbd>Ctrl</kbd> и нажав клавишу <kbd>C</kbd> один раз: <kbd>Ctrl</kbd>+<kbd>C</kbd>. Затем отпустите обе клавиши.

::::::::::::::::::::::::::::::::::::::::::::::::::

## Перехват вывода команд

Какой из этих файлов содержит наименьшее количество строк? Это простой вопрос, когда файлов всего шесть, но что, если их 6000? Наш первый шаг к решению — это запустить команду:

```bash
$ wc -l *.pdb > lengths.txt
```

Символ `>`, который здесь используется, указывает оболочке перенаправить вывод команды в файл вместо вывода на экран. Эта команда не выдаст вывода на экран, потому что всё, что команда `wc` должна была вывести, теперь записано в файл `lengths.txt`. Если файла не существовало до запуска команды, оболочка создаст его. Если файл уже существует, он будет перезаписан без лишних слов, что может привести к потере данных. Таким образом, команды с перенаправлением требуют осторожности.

Команда ls lengths.txt подтверждает, что теперь файл существует:

```bash
$ ls lengths.txt
```

```вывод
lengths.txt
```

Теперь мы можем вывести содержимое файла `lengths.txt` на экран, используя команду `cat lengths.txt`. Команда cat получила своё название от "con**cat**enate" (конкатенировать), то есть объединять, и она выводит содержимое файлов поочерёдно. В данном случае у нас только один файл, поэтому `cat` просто покажет его содержимое:

```bash
$ cat lengths.txt
```

```вывод
  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Постраничный вывод

Мы будем продолжать использовать команду `cat` в этом уроке для удобства и воспроизводимости, но у неё есть недостаток — она всегда выводит весь файл на экран. Более полезной на практике является команда `less` (например, `less lengths.txt`). Она выводит на экран один экранный блок файла и останавливается. Вы можете пролистывать вперёд, нажимая пробел, или назад, нажимая `b`. Для выхода нажмите `q`.


::::::::::::::::::::::::::::::::::::::::::::::::::

## Фильтрация вывода

Теперь мы воспользуемся командой `sort`, чтобы отсортировать содержимое файла `lengths.txt`. Но сначала мы сделаем упражнение, чтобы узнать больше о команде сортировки:

:::::::::::::::::::::::::::::::::::::::  challenge

## Что делает `sort -n`?

Файл `shell-lesson-data/exercise-data/numbers.txt` содержит следующие строки:

```source
10
2
19
22
6
```

Если мы запустим команду `sort`, передав её имя этого файла, результат будет следующим:

```вывод
10
19
2
22
6
```

Если мы запустим `sort -n` на том же файле, результат будет следующим:

```вывод
2
6
10
19
22
```

Объясните, почему опция `-n` даёт такой результат.

:::::::::::::::  solution

## Решение

Опция `-n` указывает на числовую сортировку вместо алфавитной.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Мы также будем использовать опцию `-n`, чтобы указать, что сортировка должна быть числовой, а не алфавитной. Команда _не изменяет_ файл, а просто выводит отсортированный результат на экран:

```bash
$ sort -n lengths.txt
```

```вывод
  9  methane.pdb
 12  ethane.pdb
 15  propane.pdb
 20  cubane.pdb
 21  pentane.pdb
 30  octane.pdb
107  total
```

Мы можем поместить отсортированный список строк в другой временный файл под названием `sorted-lengths.txt`, добавив `> sorted-lengths.txt` после команды, как мы сделали с `> lengths.txt`, чтобы поместить вывод команды `wc` в файл `lengths.txt`. После этого мы можем запустить другую команду, называемую `head`, чтобы получить первые несколько строк из файла `sorted-lengths.txt`:

```bash
$ sort -n lengths.txt > sorted-lengths.txt
$ head -n 1 sorted-lengths.txt
```

```вывод
  9  methane.pdb
```

Использование опции `-n 1` с командой `head` указывает, что мы хотим получить только первую строку файла; `-n 20` даст первые 20 строк и так далее. Поскольку файл `sorted-lengths.txt` содержит длины наших файлов, отсортированные от меньшего к большему, вывод команды `head` покажет файл с наименьшим количеством строк.

:::::::::::::::::::::::::::::::::::::::::  callout

## Перенаправление в тот же файл

Очень плохой идеей будет пытаться перенаправить вывод команды, которая работает с файлом, в тот же файл. Например:

```bash
$ sort -n lengths.txt > lengths.txt
```

Выполнение подобной команды может привести к неверным результатам и/или удалению содержимого файла `lengths.txt`.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Что означает >>?

Мы уже видели использование `>`, но существует похожий оператор `>>`, который работает немного иначе. Мы узнаем о различиях между этими двумя операторами, напечатав несколько строк. Мы можем использовать команду `echo`, чтобы вывести строки, например:

```bash
$ echo The echo command prints text
```

```вывод
The echo command prints text
```

Теперь протестируйте следующие команды, чтобы выявить разницу между двумя операторами:

```bash
$ echo hello > testfile01.txt
```

и:

```bash
$ echo hello >> testfile02.txt
```

Подсказка: Попробуйте выполнить каждую команду дважды подряд, а затем исследуйте файлы вывода.

:::::::::::::::  solution

## Решение

В первом примере с `>`, строка 'hello' записывается в файл `testfile01.txt`, но файл перезаписывается каждый раз при выполнении команды.

Из второго примера мы видим, что оператор `>>` также записывает 'hello' в файл (в данном случае в `testfile02.txt`), но если файл уже существует — он его не перезаписывает, а добавляет эту строку в конец файла (что и произошло при повторном вызове команды).

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Добавление данных

Мы уже познакомились с командой `head`, которая выводит строки из начала файла. Команда `tail` аналогична, но выводит строки из конца файла.

Рассмотрим файл `shell-lesson-data/exercise-data/animal-counts/animals.csv`. После выполнения этих команд выберите правильный вариант, который соответствует файлу `animals-subset.csv`:

```bash
$ head -n 3 animals.csv > animals-subset.csv
$ tail -n 2 animals.csv >> animals-subset.csv
```

1. Первые три строки файла `animals.csv`
2. Последние две строки файла `animals.csv`
3. Первые три строки и последние две строки файла `animals.csv`
4. Вторая и третья строки файла `animals.csv`

:::::::::::::::  solution

## Решение

Правильный вариант — 3. Для варианта 1 мы бы выполнили только команду `head`. Для варианта 2 мы бы выполнили только команду `tail`. Для варианта 4 мы бы должны были передать вывод команды `head` команде `tail -n 2` через конвейер с помощью команды `head -n 3 animals.csv | tail -n 2 > animals-subset.csv`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Передача вывода другой команде

В нашем примере поиска файла с наименьшим количеством строк мы используем два промежуточных файла: `lengths.txt` и `sorted-lengths.txt` для хранения вывода. Это может запутать, потому что даже после того, как вы поймёте, что делают команды `wc`, `sort` и `head`, эти промежуточные файлы затрудняют отслеживание процесса. Мы можем сделать это понятнее, запустив `sort` и `head` вместе:

```bash
$ sort -n lengths.txt | head -n 1
```

```вывод
  9  methane.pdb
```

Вертикальная черта, `|`, между двумя командами называется **каналом** (**pipe**). Она сообщает оболочке, что мы хотим использовать вывод команды слева в качестве ввода для команды справа.

Это устраняет необходимость в файле `sorted-lengths.txt`.

## Комбинирование нескольких команд

Ничто не мешает нам последовательно связывать команды через каналы. Мы можем, например, отправить вывод команды `wc` напрямую в команду `sort`, а затем отправить полученный вывод в команду `head`. Это устраняет необходимость в любых промежуточных файлах.

Начнём с использования канала для передачи вывода команды `wc` в команду `sort`:

```bash
$ wc -l *.pdb | sort -n
```

```вывод
   9 methane.pdb
  12 ethane.pdb
  15 propane.pdb
  20 cubane.pdb
  21 pentane.pdb
  30 octane.pdb
 107 total
```

Затем мы можем передать этот вывод через другой канал в команду `head`, так что полная последовательность будет выглядеть так:

```bash
$ wc -l *.pdb | sort -n | head -n 1
```

```вывод
   9  methane.pdb
```

Это похоже на математическую запись, когда функции вкладываются друг в друга, например, log(3x), где говорится: "логарифм от трёх, помноженных на x". В нашем случае алгоритм выглядит так: "head от sort от количества строк для `*.pdb`".

Использование перенаправлений и каналов в последних нескольких командах можно проиллюстрировать следующим образом:

![Перенаправления и каналы для различных команд: "wc -l *.pdb" отправляет вывод в оболочку. "wc -l *.pdb > lengths" перенаправляет вывод в файл "lengths". "wc -l *.pdb | sort -n | head -n 1" создаёт конвейер, где вывод команды "wc" становится вводом для команды "sort", вывод команды "sort" становится вводом для команды "head", а вывод команды "head" отправляется в оболочку](fig/redirects-and-pipes.svg)

:::::::::::::::::::::::::::::::::::::::  challenge

## Объединение команд через каналы

В нашем текущем каталоге мы хотим найти 3 файла с наименьшим количеством строк. Какая из перечисленных команд будет работать?

1. `wc -l * > sort -n > head -n 3`
2. `wc -l * | sort -n | head -n 1-3`
3. `wc -l * | head -n 3 | sort -n`
4. `wc -l * | sort -n | head -n 3`

:::::::::::::::  solution

## Решение

Правильный ответ — 4. Символ канала `|` используется для соединения вывода одной команды с вводом другой команды. Символ `>` используется для перенаправления стандартного вывода в файл. Попробуйте это в каталоге `shell-lesson-data/exercise-data/alkanes`!

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Инструменты, разработанные для совместной работы

Идея связывания программ друг с другом — одна из причин успеха Unix. Вместо создания огромных программ, которые пытаются выполнять множество различных задач, программисты Unix сосредотачиваются на создании множества простых инструментов, каждый из которых выполняет одну задачу хорошо и при этом хорошо взаимодействует с другими инструментами. Эта модель программирования называется «каналы и фильтры». Мы уже видели каналы; **фильтр** — это программа, такая как `wc` или `sort`, которая преобразует поток входных данных в поток выходных данных. Почти все стандартные инструменты Unix могут работать таким образом. Если не указано иное, они читают данные из стандартного ввода, выполняют с ними определённую задачу и записывают результат в стандартный вывод.

Ключевая идея заключается в том, что любая программа, которая читает строки текста из стандартного ввода и записывает строки текста в стандартный вывод, может быть скомбинирована с любой другой программой, работающей таким же образом. Вы можете _должны_ писать программы таким образом, чтобы вы и другие люди могли включать их в каналы и тем самым увеличивать их мощность.

:::::::::::::::::::::::::::::::::::::::  challenge

## Понимание работы канала

Файл под названием `animals.csv` (в каталоге `shell-lesson-data/exercise-data/animal-counts`) содержит следующие данные:

```source
2012-11-05,deer,5
2012-11-05,rabbit,22
2012-11-05,raccoon,7
2012-11-06,rabbit,19
2012-11-06,deer,2
2012-11-06,fox,4
2012-11-07,rabbit,16
2012-11-07,bear,1
```

Какой текст проходит через каждый из каналов и окончательное перенаправление в конвейере ниже? Обратите внимание, что команда `sort -r` сортирует в обратном порядке.

```bash
$ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt
```

Подсказка: стройте конвейер команд поочерёдно, чтобы проверить своё понимание.

:::::::::::::::  solution

## Решение

Команда `head` извлекает первые 5 строк из файла `animals.csv`. Затем команда `tail` извлекает последние 3 строки из этих 5. Команда `sort -r` сортирует эти 3 строки в обратном порядке. Наконец, результат записывается в файл `final.txt`. Содержимое этого файла можно проверить, выполнив команду `cat final.txt`. Файл должен содержать следующие строки:

```source
2012-11-06,rabbit,19
2012-11-06,deer,2
2012-11-05,raccoon,7
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Построение канала

Для файла `animals.csv` из предыдущего упражнения рассмотрим следующую команду:

```bash
$ cut -d , -f 2 animals.csv
```

Команда `cut` используется для удаления или "вырезания" определённых разделов из каждой строки файла. `cut` ожидает, что строки будут разделены на столбцы с помощью символа <kbd>Tab</kbd>. Символ, используемый таким образом, называется разделителем. В приведённом выше примере мы используем опцию `-d`, чтобы указать запятую в качестве символа-разделителя. Мы также использовали опцию `-f`, чтобы указать, что мы хотим извлечь второй столбец. Это даст следующий вывод:

```вывод
deer
rabbit
raccoon
rabbit
deer
fox
rabbit
bear
```

Команда `uniq` фильтрует соседние повторяющиеся строки в файле. Как можно расширить этот конвейер (с помощью `uniq` и другой команды), чтобы узнать, какие животные содержатся в файле (без повторений в их именах)?

:::::::::::::::  solution

## Solution

```bash
$ cut -d , -f 2 animals.csv | sort | uniq
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Какой канал?

Файл `animals.csv` содержит 8 строк данных в следующем формате:

```вывод
2012-11-05,deer,5
2012-11-05,rabbit,22
2012-11-05,raccoon,7
2012-11-06,rabbit,19
...
```

Команда `uniq` имеет опцию `-c`, которая выводит количество вхождений каждой строки во входных данных. Предположим, что текущий каталог — это `shell-lesson-data/exercise-data/animal-counts`. Какую команду вы бы использовали для создания таблицы, которая показывает общее количество каждого типа животных в файле?

1. `sort animals.csv | uniq -c`
2. `sort -t, -k2,2 animals.csv | uniq -c`
3. `cut -d, -f 2 animals.csv | uniq -c`
4. `cut -d, -f 2 animals.csv | sort | uniq -c`
5. `cut -d, -f 2 animals.csv | sort | uniq -c | wc -l`

:::::::::::::::  solution

## Решение

Правильный ответ — вариант 4. Если вам сложно понять, почему, попробуйте запустить команды или отдельные части конвейера (убедитесь, что вы находитесь в каталоге `shell-lesson-data/exercise-data/animal-counts`).

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Конвейер Нелли: проверка файлов

Нелли исследовала образцы с помощью анализатора и создала 17 файлов в каталоге `north-pacific-gyre/2012-07-03`, описанном ранее. Для быстрой проверки, начиная с каталога `shell-lesson-data`, Нелли вводит:

```bash
$ cd north-pacific-gyre/2012-07-03
$ wc -l *.txt
```

Вывод состоит из 18 строк, которые выглядят так:

```вывод
300 NENE01729A.txt
300 NENE01729B.txt
300 NENE01736A.txt
300 NENE01751A.txt
300 NENE01751B.txt
300 NENE01812A.txt
... ...
```

Затем она вводит:

```bash
$ wc -l *.txt | sort -n | head -n 5
```

```вывод
 240 NENE02018B.txt
 300 NENE01729A.txt
 300 NENE01729B.txt
 300 NENE01736A.txt
 300 NENE01751A.txt
```

Ой, один из файлов на 60 строк короче остальных. Когда она проверила его, она вспомнила, что провела этот анализ в 8 утра в понедельник — кто-то, вероятно, пользовался машиной на выходных, и она забыла сбросить настройки. Прежде чем повторно запустить этот образец, она проверяет, есть ли файлы с избыточными данными:

```bash
$ wc -l *.txt | sort -n | tail -n 5
```

```вывод
 300 NENE02040B.txt
 300 NENE02040Z.txt
 300 NENE02043A.txt
 300 NENE02043B.txt
5040 total
```

Эти числа выглядят нормально — но что делает 'Z' в третьей строке с конца? Все её образцы должны быть помечены как 'A' или 'B'; по правилам её лаборатории, буква 'Z' используется для обозначения образцов с отсутствующей информацией. Чтобы найти другие такие файлы, она вводит:

```bash
$ ls *Z.txt
```

```вывод
NENE01971Z.txt    NENE02040Z.txt
```

Действительно, когда она проверила журнал на своём ноутбуке, оказалось, что для этих образцов не была записана глубина. Поскольку слишком поздно получать эту информацию каким-либо другим способом, ей придётся исключить эти два файла из анализа. Она могла бы удалить их с помощью `rm`, но для некоторых будущих анализов глубина не важна, поэтому ей нужно будет быть внимательной и использовать для выбора файлов выражения с подстановочными символами, такие как NENE*A.txt NENE*B.txt.

:::::::::::::::::::::::::::::::::::::::  challenge

## Удаление ненужных файлов

Предположим, вы хотите удалить обработанные файлы данных и оставить только сырые файлы и скрипт обработки для экономии места. Сырые файлы имеют расширение `.dat`, а обработанные файлы — расширение `.txt`. Какой из следующих вариантов удалит все обработанные файлы данных и _только_ их?

1. `rm ?.txt`
2. `rm *.txt`
3. `rm * .txt`
4. `rm *.*`

:::::::::::::::  solution

## Решение

1. Это удалит `.txt`-файлы с односимвольными именами.
2. Это правильный ответ.
3. Оболочка расширит `*`, чтобы соответствовать всем файлам в текущем каталоге, поэтому команда попытается удалить все совпадающие файлы и дополнительный файл под названием `.txt` (обратите внимание на пробел в команде).
4. Оболочка расширит `*.*`, чтобы соответствовать всем именам файлов, содержащим хотя бы одну точку, включая обработанные файлы (`.txt`) и сырые файлы (`.dat`).

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::



:::::::::::::::::::::::::::::::::::::::: keypoints

- `wc` подсчитывает количество строк, слов и символов во входных данных.
- `cat` отображает содержимое входных данных.
- `sort` сортирует входные данные.
- `head` отображает первые 10 строк входных данных.
- `tail` отображает последние 10 строк входных данных.
- command `> [file]` перенаправляет вывод команды в файл (перезаписывая его содержимое).
- command `>> [file]` добавляет вывод команды в конец файла.
- `[first] | [second]` — это конвейер: вывод первой команды используется в качестве ввода для второй команды.
- Лучший способ использования оболочки — это использование каналов для объединения простых однопрофильных программ (фильтров).

::::::::::::::::::::::::::::::::::::::::::::::::::
