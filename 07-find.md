---
title: Поиск
teaching: 25
exercises: 20
---

::::::::::::::::::::::::::::::::::::::: objectives

- Использовать команду `grep` для поиска строк в текстовых файлах, которые соответствуют простым шаблонам.
- Использовать команду `find` для поиска файлов и каталогов, имена которых соответствуют простым шаблонам.
- Использовать вывод одной команды как аргумент(ы) командной строки для другой команды.
- Объяснить, что такое "текстовые" и "бинарные" файлы, и почему многие распространённые инструменты плохо работают с последними.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Как найти файлы?
- Как найти данные в файлах?

::::::::::::::::::::::::::::::::::::::::::::::::::

Так же как многие из нас используют слово "_гуглить_" как глагол, означающий "искать", Unix-программисты часто используют слово "_грепать_". 'grep' — это сокращение от 'global/regular expression/print', что описывает частую последовательность операций в ранних текстовых редакторах Unix. Это также название очень полезной программы командной строки.

`grep` находит и выводит строки в файлах, которые соответствуют заданному шаблону. Для наших примеров мы будем использовать файл, содержащий три хайку,
взятые из [конкурса 1998 года](https://web.archive.org/web/19991201042211/http://salon.com/21st/chal/1998/01/26chal.html) в журнале _Salon_ (Благодарности авторам Биллу Торкассо, Ховарду Кордеру и Маргарет Сегалл. См. страницы [1](https://web.archive.org/web/20000310061355/http://www.salon.com/21st/chal/1998/02/10chal2.html) и [2](https://web.archive.org/web/20000229135138/http://www.salon.com/21st/chal/1998/02/10chal3.html)). Для примеров мы будем работать в подкаталоге `writing`:

```bash
$ cd
$ cd Desktop/shell-lesson-data/exercise-data/writing
$ cat haiku.txt
```

```output
The Tao that is seen
Is not the true Tao, until
You bring fresh toner.

With searching comes loss
and the presence of absence:
"My Thesis" not found.

Yesterday it worked
Today it is not working
Software is like that.
```

Найдём строки, содержащие слово 'not':

```bash
$ grep not haiku.txt
```

```output
Is not the true Tao, until
"My Thesis" not found
Today it is not working
```

Здесь `not` — это шаблон, по которому мы ищем. Команда `grep` ищет в файле строки, соответствующие указанному шаблону. Чтобы её использовать, напишите `grep`, затем укажите шаблон для поиска и, наконец, имя файла (или файлов), в которых выполняется поиск.

Результат — это три строки из файла, содержащие последовательность 'not'.

По умолчанию `grep` ищет шаблон с учётом регистра. Кроме того, шаблон поиска может быть частью слова, как мы увидим в следующем примере.

Попробуем найти шаблон 'The'.

```bash
$ grep The haiku.txt
```

```output
The Tao that is seen
"My Thesis" not found.
```

На этот раз выводятся две строки, содержащие символы 'The', одна из которых содержит шаблон поиска внутри более длинного слова — 'Thesis'.

Чтобы ограничить совпадения строками, содержащими только слово 'The', можно использовать опцию `-w` для поиска по границам слов.

Позже в этом уроке мы также узнаем, как можно изменить поведение `grep` с учётом регистра.

```bash
$ grep -w The haiku.txt
```

```output
The Tao that is seen
```

Обратите внимание, что граница слова включает начало и конец строки, а не только пробелы вокруг букв. Иногда нам нужно искать не отдельное слово, а фразу. Это также можно сделать с помощью `grep`, обрамляя фразу в кавычки.

```bash
$ grep -w "is not" haiku.txt
```

```output
Today it is not working
```

Мы уже видели, что необязательно заключать одиночные слова в кавычки, но это полезно при поиске нескольких слов. Это также облегчает различие между искомым шаблоном или фразой и файлом, в котором выполняется поиск. Мы будем использовать кавычки в оставшихся примерах.

Ещё одна полезная опция — `-n`, которая пронумеровывает строки, соответствующие шаблону:

```bash
$ grep -n "it" haiku.txt
```

```output
5:With searching comes loss
9:Yesterday it worked
10:Today it is not working
```

Здесь видно, что строки 5, 9 и 10 содержат последовательность 'it'.

Мы можем комбинировать опции (т.е. флаги), как и с другими Unix-командами. Например, давайте найдём строки, содержащие слово 'the'. Мы можем совместить опцию `-w` для поиска строк с целым словом 'the' и `-n` для нумерации соответствующих строк:

```bash
$ grep -n -w "the" haiku.txt
```

```output
2:Is not the true Tao, until
6:and the presence of absence:
```

Теперь используем опцию `-i`, чтобы сделать наш поиск нечувствительным к регистру:

```bash
$ grep -n -w -i "the" haiku.txt
```

```output
1:The Tao that is seen
2:Is not the true Tao, until
6:and the presence of absence:
```

Далее используем опцию `-v`, чтобы инвертировать наш поиск, т.е. вывести строки, которые не содержат слово 'the'.

```bash
$ grep -n -w -v "the" haiku.txt
```

```output
1:The Tao that is seen
3:You bring fresh toner.
4:
5:With searching comes loss
7:"My Thesis" not found.
8:
9:Yesterday it worked
10:Today it is not working
11:Software is like that.
```

Если использовать опцию `-r` (рекурсивно), `grep` может искать шаблон в файлах и подкаталогах.

Попробуем найти шаблон `Yesterday` рекурсивно в каталоге `shell-lesson-data/exercise-data/writing`:

```bash
$ grep -r Yesterday .
```

```output
./LittleWomen.txt:"Yesterday, when Aunt was asleep and I was trying to be as still as a
./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then
./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my
./haiku.txt:Yesterday it worked
```

У команды `grep` есть много других опций. Чтобы узнать, какие именно, можно ввести:

```bash
$ grep --help
```

```output
Usage: grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE or standard input.
PATTERN is, by default, a basic regular expression (BRE).
Example: grep -i 'hello world' menu.h main.c

Regexp selection and interpretation:
  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)
  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings
  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)
  -P, --perl-regexp         PATTERN is a Perl regular expression
  -e, --regexp=PATTERN      use PATTERN for matching
  -f, --file=FILE           obtain PATTERN from FILE
  -i, --ignore-case         ignore case distinctions
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline

Miscellaneous:
...        ...        ...
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Использование `grep`

Какая команда приведёт к следующему результату:

```output
and the presence of absence:
```

1. `grep "of" haiku.txt`
2. `grep -E "of" haiku.txt`
3. `grep -w "of" haiku.txt`
4. `grep -i "of" haiku.txt`

:::::::::::::::  solution

## Решение

Правильный ответ — 3, так как опция `-w` ищет совпадения только по целому слову. Другие опции также найдут 'of', если оно является частью другого слова.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## Подстановочные символы (Wildcards)

Основная сила команды `grep` заключается не в её опциях, а в том, что шаблоны могут включать подстановочные символы. (Техническое название для них — **регулярные выражения**, откуда происходит 're' в `grep`.) Регулярные выражения и сложны, и мощны; если вы хотите делать сложные запросы, обратитесь к уроку на [этом сайте](https://librarycarpentry.org/lc-data-intro/01-regular-expressions.html). Как пример, давайте найдём строки, в которых 'o' находится на второй позиции:

```bash
$ grep -E "^.o" haiku.txt
```

```output
You bring fresh toner.
Today it is not working
Software is like that.
```

Мы используем опцию `-E` и заключаем шаблон в кавычки, чтобы оболочка не пыталась его интерпретировать. (Если бы в шаблоне был символ `*`, оболочка попыталась бы его развернуть до выполнения команды `grep`.) Символ `^` в шаблоне закрепляет совпадение за началом строки. Точка (`.`) соответствует любому одиночному символу (так же, как и `?` в оболочке), а `o` совпадает с фактической буквой 'o'.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Отслеживание вида

У Лии есть несколько сотен файлов данных, сохранённых в одной директории, каждый из которых отформатирован так:

```source
2012-11-05,deer,5
2012-11-05,rabbit,22
2012-11-05,raccoon,7
2012-11-06,rabbit,19
2012-11-06,deer,2
2012-11-06,fox,4
2012-11-07,rabbit,16
2012-11-07,bear,1
```

Она хочет написать сценарий оболочки, который принимает вид как первый аргумент командной строки, а директорию как второй аргумент. Сценарий должен возвращать один файл, называемый `<species>.txt`, содержащий список дат и количество встреченного вида в каждую из дат. Например, используя данные выше, файл `rabbit.txt` будет содержать:

```source
2012-11-05,22
2012-11-06,19
2012-11-07,16
```

Ниже каждая строка содержит отдельную команду или канал. Расположите их в правильном порядке, чтобы достичь цели Лии:

```bash
cut -d : -f 2
>
|
grep -w $1 -r $2
|
$1.txt
cut -d , -f 1,3
```

Подсказка: используйте `man grep`, чтобы узнать, как искать текст рекурсивно в директории, и `man cut`, чтобы выбрать более одного поля в строке.

Пример такого файла находится в каталоге `shell-lesson-data/exercise-data/animal-counts/animals.csv`.

:::::::::::::::  solution

## Решение

```source
grep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 > $1.txt
```

На самом деле можно поменять местами команды `cut`, и результат всё равно будет правильным. Попробуйте изменить порядок команд `cut` в командной строке и посмотрите на результат каждого шага, чтобы понять, почему это работает.

Этот скрипт можно вызвать так:

```bash
$ bash count-species.sh bear .
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Маленькие женщины

Вы и ваш друг, закончив читать книгу "_Маленькие женщины_" Луизы Мэй Олкотт, спорите. Из четырёх сестёр в книге — Джо, Мег, Бет и Эми — ваш друг считает, что Джо упоминалась чаще всего. Однако вы уверены, что это была Эми. К счастью, у вас есть файл `LittleWomen.txt`, содержащий полный текст романа (`shell-lesson-data/exercise-data/writing/LittleWomen.txt`). Используя цикл `for`, как бы вы подсчитали количество упоминаний каждой из четырёх сестёр?

Подсказка: одно из решений может включать команды `grep` и `wc`, соединённые с помощью `|`, а другое может использовать опции `grep`. Задачу можно решить несколькими способами, выбор которых обычно зависит от правильности результата, элегантности, удобочитаемости и скорости выполнения.

:::::::::::::::  solution

## Solutions

```source
for sis in Jo Meg Beth Amy
do
    echo $sis:
    grep -ow $sis LittleWomen.txt | wc -l
done
```

Альтернативное, чуть менее удачное решение:

```source
for sis in Jo Meg Beth Amy
do
    echo $sis:
    grep -ocw $sis LittleWomen.txt
done
```

Это решение хуже, потому что `grep -c` сообщает только количество строк с совпадениями. Общее количество совпадений будет ниже, если в строке содержится более одного совпадения.

Внимательные пользователи могли заметить, что имена персонажей иногда появляются в заголовках глав в верхнем регистре (например, 'MEG GOES TO VANITY FAIR'). Если вы хотите учитывать и такие случаи, можно добавить опцию `-i` для игнорирования регистра (хотя в данном случае это не повлияет на ответ о том, какая сестра упоминалась чаще всего).

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

В то время как `grep` находит строки в файлах, команда `find` находит сами файлы.
Опять же, у этой команды множество опций. Чтобы показать, как работают самые простые из них, мы воспользуемся деревом директорий `shell-lesson-data/exercise-data`, показанным ниже.

```output
.
├── animal-counts/
│   └── animals.csv
├── creatures/
│   ├── basilisk.dat
│   ├── minotaur.dat
│   └── unicorn.dat
├── numbers.txt
├── alkanes/
│   ├── cubane.pdb
│   ├── ethane.pdb
│   ├── methane.pdb
│   ├── octane.pdb
│   ├── pentane.pdb
│   └── propane.pdb
└── writing/
    ├── haiku.txt
    └── LittleWomen.txt
```

Директория `exercise-data` содержит один файл `numbers.txt` и четыре каталога: `animal-counts`, `creatures`, `alkanes` и `writing`, содержащие различные файлы.

Для начала давайте запустим команду `find .` (не забудьте выполнить эту команду из директории `shell-lesson-data/exercise-data`).

```bash
$ find .
```

```output
.
./writing
./writing/LittleWomen.txt
./writing/haiku.txt
./creatures
./creatures/basilisk.dat
./creatures/unicorn.dat
./creatures/minotaur.dat
./animal-counts
./animal-counts/animals.csv
./numbers.txt
./alkanes
./alkanes/ethane.pdb
./alkanes/propane.pdb
./alkanes/octane.pdb
./alkanes/pentane.pdb
./alkanes/methane.pdb
./alkanes/cubane.pdb
```

`.` означает текущую рабочую директорию, откуда мы и начнём наш поиск. Результат работы команды `find` — это список всех файлов и директорий в текущей рабочей директории. Это может показаться бесполезным, но `find` имеет множество опций, чтобы фильтровать результаты, и в этом уроке мы рассмотрим некоторые из них.

Первая опция в нашем списке — `-type d`, которая означает 'объекты, являющиеся директориями'. Действительно, результатом выполнения команды будет список пяти директорий (включая `.`):

```bash
$ find . -type d
```

```output
.
./writing
./creatures
./animal-counts
./alkanes
```

Заметьте, что объекты, найденные `find`, не выводятся в каком-либо определённом порядке. Если изменить `-type d` на `-type f`, то будет выведен список всех файлов:

```bash
$ find . -type f
```

```output
./writing/LittleWomen.txt
./writing/haiku.txt
./creatures/basilisk.dat
./creatures/unicorn.dat
./creatures/minotaur.dat
./animal-counts/animals.csv
./numbers.txt
./alkanes/ethane.pdb
./alkanes/propane.pdb
./alkanes/octane.pdb
./alkanes/pentane.pdb
./alkanes/methane.pdb
./alkanes/cubane.pdb
```

Теперь попробуем найти файлы по имени:

```bash
$ find . -name *.txt
```

```output
./numbers.txt
```

Мы ожидали найти все текстовые файлы, но был выведен только `./numbers.txt`. Проблема в том, что оболочка разворачивает подстановочные символы, такие как `*`, _до того_, как команды выполняются. Так как `*.txt` в текущей директории разворачивается в `./numbers.txt`, фактически выполненная команда была:

```bash
$ find . -name numbers.txt
```

find сделал то, что мы попросили, некорректен был сам запрос.

Чтобы получить нужный результат, сделаем то же, что и с grep: заключим `*.txt` в кавычки, чтобы предотвратить развёртывание символа `*`. Таким образом, `find` получит шаблон `*.txt`, а не развернутое имя файла `numbers.txt`:

```bash
$ find . -name "*.txt"
```

```output
./writing/LittleWomen.txt
./writing/haiku.txt
./numbers.txt
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Сравнение `ls` и `find`

Команды `ls` и `find` могут выполнять схожие задачи при правильных опциях, но в обычных условиях `ls` выводит всё, что может, а `find` ищет объекты с определёнными свойствами и показывает их.

::::::::::::::::::::::::::::::::::::::::::::::::::

Как мы уже говорили ранее, сила командной строки заключается в комбинировании инструментов. Мы видели, как это делается с помощью каналов (pipes); теперь рассмотрим другой приём. Как мы только что видели, `find . -name "*.txt"` возвращает список всех текстовых файлов в текущей директории и ниже. Как мы можем объединить это с `wc -l`, чтобы подсчитать количество строк в этих файлах?

Самый простой способ — использовать команду `find` внутри `$()`:

```bash
$ wc -l $(find . -name "*.txt")
```

```output
  21022 ./writing/LittleWomen.txt
     11 ./writing/haiku.txt
      5 ./numbers.txt
  21038 total
```

Когда оболочка выполняет эту команду, первое, что она делает, — это запускает всё, что находится внутри `$()`. Затем она заменяет выражение `$()` на результат этой команды. Так как результат команды `find` — это три имени файлов `./writing/LittleWomen.txt`, `./writing/haiku.txt` и `./numbers.txt`, оболочка формирует команду:

```bash
$ wc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt
```

что и требовалось. Это расширение — то же самое, что делает оболочка при развёртывании подстановочных символов, таких как `*` и `?`, но с возможностью использовать любую команду как 'собственный подстановочный символ'.

Очень часто команды `find` и `grep` используются вместе. Первая находит файлы, соответствующие шаблону; вторая ищет строки внутри этих файлов, соответствующие другому шаблону. Например, мы можем найти файлы `.txt`, содержащие слово "searching", осуществив поиск этого слова во всех `.txt` файлах в текущей директории:

```bash
$ grep "searching" $(find . -name "*.txt")
```

```output
./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was
./writing/haiku.txt:With searching comes loss
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Поиск и исключение

Опция `-v` для `grep` инвертирует поиск по шаблону, выводя только строки,
которые _не_ соответствуют шаблону. Учитывая это, какая из следующих команд
найдет все файлы с расширением `.dat` в директории `creatures`,
кроме `unicorn.dat`?
После того как подумаете над ответом, вы можете протестировать команды
в директории `shell-lesson-data/exercise-data`.

1. `find creatures -name "*.dat" | grep -v unicorn`
2. `find creatures -name *.dat | grep -v unicorn`
3. `grep -v "unicorn" $(find creatures -name "*.dat")`
4. Ни один из предложенных вариантов.

:::::::::::::::  solution

## Решение

Первый вариант правильный. Заключение шаблона поиска в кавычки предотвращает
его развертывание оболочкой, и шаблон передается команде `find`.

Второй вариант также работает в данном случае, так как оболочка пытается развернуть `*.dat`,
но в текущей директории нет файлов `*.dat`,
поэтому подстановочный символ передается команде `find`.
Мы впервые сталкивались с этим в [эпизоде 3](03-create.md).

Третий вариант неверен, так как он ищет в содержимом файлов строки,
которые не содержат 'unicorn', а не выполняет поиск по именам файлов.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## Двоичные файлы

До этого мы фокусировались исключительно на поиске шаблонов в текстовых файлах. А что если ваши данные хранятся в виде изображений, баз данных или в каком-то другом формате?

Существует несколько инструментов, расширяющих возможности `grep` для работы с нетекстовыми форматами. Однако более универсальным подходом является преобразование данных в текст или извлечение элементов текста из данных. С одной стороны, это делает простые задачи легко выполнимыми. С другой стороны, сложные задачи обычно становятся невозможными. Например, легко написать программу, которая извлечет X и Y координаты из изображений для дальнейшей работы с ними в `grep`, но как бы вы написали программу для поиска значений в электронной таблице, ячейки которой содержат формулы?

Последний вариант — признать, что возможности командной строки и обработки текста ограничены, и использовать другой язык программирования. Когда наступит время для этого, не судите оболочку слишком строго. Многие современные языки программирования позаимствовали у неё множество идей, а подражание — это самая искренняя форма признания.

::::::::::::::::::::::::::::::::::::::::::::::::::

Unix-оболочка старше большинства людей, которые ею пользуются. Она существует так долго, потому что это одна из самых продуктивных программных сред, когда-либо созданных, а возможно и _самая_ продуктивная. Ее синтаксис может быть загадочным, но те, кто освоил его, могут экспериментировать с различными командами интерактивно, а затем использовать полученные знания для автоматизации своей работы. Графические пользовательские интерфейсы могут быть проще в освоении на начальном этапе, но как только освоишь работу с оболочкой, ее продуктивность несравнима ни с чем. Как написал Альфред Норт Уайтхед в 1911 году: "Цивилизация продвигается вперед, расширяя число важных операций, которые мы можем выполнять, не задумываясь о них".

:::::::::::::::::::::::::::::::::::::::  challenge

## Понимание конвейера команды `find`

Напишите короткий поясняющий комментарий к следующему скрипту оболочки:

```bash
wc -l $(find . -name "*.dat") | sort -n
```

:::::::::::::::  solution

## Solution

1. Найти все файлы с расширением `.dat` рекурсивно, начиная с текущей директории.
2. Подсчитать количество строк в каждом из этих файлов.
3. Отсортировать результат второго шага по возрастанию.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- `find` ищет файлы с определенными свойствами, которые соответствуют шаблонам.
- `grep` выбирает строки в файлах, которые соответствуют шаблонам.
- `--help` — это опция, поддерживаемая многими bash-командами и программами, которые можно запустить в Bash, для вывода дополнительной информации о том, как использовать эти команды или программы.
- `man [команда]` отображает руководство для указанной команды.
- `$([команда])` подставляет вывод команды на место.

::::::::::::::::::::::::::::::::::::::::::::::::::
