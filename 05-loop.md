---
title: Циклы
teaching: 40
exercises: 10
---

::::::::::::::::::::::::::::::::::::::: objectives

- Написать цикл, который применяет одну или несколько команд отдельно к каждому файлу из набора файлов.
- Отслеживать значения, принимаемые переменной цикла во время выполнения цикла.
- Объяснить разницу между именем переменной и её значением.
- Объяснить, почему в именах файлов не следует использовать пробелы и некоторые символы пунктуации.
- Показать, как посмотреть недавно выполненные команды.
- Повторить недавно выполненные команды без их повторного ввода.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Как можно выполнить одинаковые действия для множества различных файлов?

::::::::::::::::::::::::::::::::::::::::::::::::::

**Циклы** — это программная конструкция, которая позволяет нам повторять команду или набор команд для каждого элемента из списка. Это ключевой элемент повышения производительности посредством автоматизации. Как и использование подстановочных символов и автодополнения, циклы сокращают количество вводимых данных (а значит, уменьшают вероятность ошибок).

Предположим, у нас есть несколько сотен файлов с данными о геномах, таких как `basilisk.dat`, `minotaur.dat` и `unicorn.dat`. Для этого примера мы будем использовать каталог `exercise-data/creatures`, в котором есть только три примера файлов, но принципы можно применить к гораздо большему количеству файлов одновременно.

Структура этих файлов одинакова: общее название, классификация и дата обновления представлены в первых трёх строках, а последовательности ДНК — в следующих строках. Давайте посмотрим на файлы:


```bash
$ head -n 5 basilisk.dat minotaur.dat unicorn.dat
```

Мы хотим вывести классификацию каждого вида, которая указана во второй строке каждого файла. Для каждого файла нам нужно выполнить команду `head -n 2`, передав её результат команде `tail -n 1`. Мы используем цикл для решения этой задачи, но сначала рассмотрим общую форму цикла, используя псевдокод:

```bash
# Слово "for" указывает на начало команды цикла "For"
for thing in list_of_things
# Слово "do" указывает на начало списка выполняемых команд
do
    # Отступы в цикле не обязательны, но улучшают читаемость
    operation_using/command $thing
# Слово "done" указывает на конец цикла
done
```

и мы можем применить это к нашему примеру вот так:

```bash
$ for filename in basilisk.dat minotaur.dat unicorn.dat
> do
>     echo $filename
>     head -n 2 $filename | tail -n 1
> done
```

```вывод
basilisk.dat
CLASSIFICATION: basiliscus vulgaris
minotaur.dat
CLASSIFICATION: bos hominus
unicorn.dat
CLASSIFICATION: equus monoceros
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Следите за приглашением

При вводе нашего цикла приглашение оболочки меняется с `$` на `>`, а затем обратно. Второе приглашение `>` отличается, чтобы напомнить нам, что мы ещё не закончили вводить полную команду. Для разделения двух команд на одной строке можно использовать точку с запятой `;`.

::::::::::::::::::::::::::::::::::::::::::::::::::

Когда оболочка видит ключевое слово `for`, она знает, что нужно повторить команду (или группу команд) для каждого элемента списка. Каждый раз, когда цикл выполняется (это называется итерацией), элемент списка последовательно присваивается переменной, а команды внутри цикла выполняются, после чего цикл переходит к следующему элементу. Внутри цикла мы вызываем значение переменной, поставив перед её именем знак `$`. Этот символ сообщает интерпретатору оболочки, что это имя переменной, и нужно подставить её значение, а не рассматривать как текст или внешнюю команду.

В этом примере список — это три имени файлов: `basilisk.dat`, `minotaur.dat` и `unicorn.dat`. Каждый раз, когда выполняется итерация, мы сначала используем команду `echo`, чтобы вывести текущее значение переменной `$filename`. Это не обязательно для результата, но полезно для наглядности. Затем мы выполняем команду `head` для файла, на который ссылается `$filename`. В первый раз, когда цикл выполняется, `$filename` равно `basilisk.dat`. Интерпретатор выполняет команду `head` для `basilisk.dat` и передаёт первые две строки в команду `tail`, которая затем выводит вторую строку файла. На второй итерации `$filename` становится `minotaur.dat`, и процесс повторяется. На третьей итерации `$filename` становится `unicorn.dat`, и снова выполняется команда `head`, а затем `tail`. После третьей итерации оболочка завершает цикл `for`.

:::::::::::::::::::::::::::::::::::::::::  callout

## Одинаковые символы, разные значения

Здесь мы видим, что `>` используется как приглашение оболочки, в то время как `>` также используется для перенаправления вывода. Аналогично, `$` используется как приглашение оболочки, но, как мы видели ранее, также используется для получения значения переменной.

Если _оболочка_ выводит `>` или `$`, она ожидает, что вы что-то введёте, и эти символы являются приглашением.

Если _вы_ вводите `>` или `$`, это инструкция для оболочки перенаправить вывод или получить значение переменной.

::::::::::::::::::::::::::::::::::::::::::::::::::

При использовании переменных можно также заключать их имена в фигурные скобки, чтобы явно выделить имя переменной: `$filename` эквивалентно `${filename}`, но отличается от `${file}name`. Вы можете встретить такую нотацию в программах других людей.

Мы назвали переменную в этом цикле `filename`, чтобы её назначение было более очевидным для читателей. Самой оболочке всё равно, как называется переменная; если бы мы написали этот цикл так:

```bash
$ for x in basilisk.dat minotaur.dat unicorn.dat
> do
>     head -n 2 $x | tail -n 1
> done
```

или так:

```bash
$ for temperature in basilisk.dat minotaur.dat unicorn.dat
> do
>     head -n 2 $temperature | tail -n 1
> done
```

он работал бы точно так же. _Не делайте так_. Программы полезны только тогда, когда их могут понять люди, поэтому бессмысленные имена (например, `x`) или вводящие в заблуждение имена (например, `temperature`) увеличивают вероятность того, что программа не будет делать то, что ожидают её пользователи.

В приведённых выше примерах переменные (`thing`, `filename`, `x` и `temperature`) могли быть названы как угодно, главное, чтобы это было понятно и тому, кто пишет код, и тому, кто его читает.

Отметим также, что циклы можно использовать не только для обработки имён файлов, но и для работы с числами или подмножествами данных.

:::::::::::::::::::::::::::::::::::::::  challenge

## Напишите свой цикл

Как бы вы написали цикл, который выводит все числа от 0 до 9?

:::::::::::::::  solution

## Решение

```bash
$ for loop_variable in 0 1 2 3 4 5 6 7 8 9
> do
>     echo $loop_variable
> done
```

```вывод
0
1
2
3
4
5
6
7
8
9
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Переменные в циклах

Это упражнение относится к каталогу `shell-lesson-data/exercise-data/alkanes`. Команда `ls *.pdb` выводит следующий результат:

```вывод
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
```

Каков результат выполнения следующего кода?

```bash
$ for datafile in *.pdb
> do
>     ls *.pdb
> done
```

Теперь, каков результат выполнения следующего кода?

```bash
$ for datafile in *.pdb
> do
>     ls $datafile
> done
```

Почему эти два цикла дают разные результаты?

:::::::::::::::  solution

## Решение

Первый блок кода выводит один и тот же результат на каждой итерации цикла. Оболочка расширяет подстановочный символ `*.pdb` внутри тела цикла (а также до начала цикла), чтобы он соответствовал всем файлам, оканчивающимся на `.pdb`, и затем выводит их с помощью `ls`. Цикл будет выглядеть так:

```bash
$ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> do
>     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
> done
```

```вывод
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
```

Во втором блоке кода на каждой итерации цикла выводится разный файл. Значение переменной `datafile` вычисляется с использованием `$datafile` и затем выводится с помощью `ls`.

```вывод
cubane.pdb
ethane.pdb
methane.pdb
octane.pdb
pentane.pdb
propane.pdb
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Ограничение набора файлов

Каков будет результат выполнения следующего цикла в каталоге `shell-lesson-data/exercise-data/alkanes`?

```bash
$ for filename in c*
> do
>     ls $filename
> done
```

1. Файлы не будут перечислены.
2. Будут перечислены все файлы.
3. Будут перечислены только `cubane.pdb`, `octane.pdb` и `pentane.pdb`.
4. Будет перечислен только `cubane.pdb`.

:::::::::::::::  solution

## Решение

Правильный ответ — 4. `*` соответствует нулю или более символам, поэтому будет совпадение с любым именем файла, начинающимся с буквы `c` и содержащим ноль или более других символов.

:::::::::::::::::::::::::

Чем будет отличаться вывод, если вместо этого использовать следующую команду?

```bash
$ for filename in *c*
> do
>     ls $filename
> done
```

1. Будут перечислены те же файлы.
2. На этот раз будут перечислены все файлы.
3. На этот раз файлы не будут перечислены.
4. Будут перечислены файлы `cubane.pdb` и `octane.pdb`.
5. Будет перечислен только файл `octane.pdb`.

:::::::::::::::  solution

## Solution

Правильный ответ — 4. `*` соответствует нулю или более символам, поэтому имя файла, в котором есть ноль или более символов перед буквой `c` и ноль или более символов после неё, будет совпадать.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Сохранение в файл в цикле — Часть 1

При запуске в каталоге `shell-lesson-data/exercise-data/alkanes,` каков эффект этого цикла?

```bash
for alkanes in *.pdb
do
    echo $alkanes
    cat $alkanes > alkanes.pdb
done
```

1. Будут выведены `cubane.pdb`,  `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` и `propane.pdb`, а текст из `propane.pdb` будет сохранён в файл `alkanes.pdb`.
2. Будут выведены `cubane.pdb`,  `ethane.pdb`, `methane.pdb`, и текст всех трёх файлов будет объединён и сохранён в файл под названием `alkanes.pdb`.
3. Будут выведены `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` и `pentane.pdb`, а текст из `propane.pdb` будет сохранён в файл `alkanes.pdb`.
4. Ничего из вышеперечисленного.

:::::::::::::::  solution

## Решение

Правильный ответ — `1`. Текст из каждого файла по очереди записывается в файл `alkanes.pdb`. Однако файл перезаписывается на каждой итерации цикла, поэтому конечное содержимое файла `alkanes.pdb` будет текстом из файла `propane.pdb`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Сохранение в файл в цикле — Часть 2

Также при запуске в каталоге shell-lesson-data/exercise-data/alkanes, каков будет результат выполнения следующего цикла?

```bash
for datafile in *.pdb
do
    cat $datafile >> all.pdb
done
```

1. Весь текст из файлов `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb` и `pentane.pdb` будет объединён и сохранён в файл под названием `all.pdb`.
2. Текст из файла `ethane.pdb` будет сохранён в файл под названием `all.pdb`.
3. Весь текст из файлов `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb` и `propane.pdb` будет объединён и сохранён в файл под названием `all.pdb`.
4. Весь текст из файлов `cubane.pdb`, `ethane.pdb`, `methane.pdb`, `octane.pdb`, pentane.pdb и `propane.pdb` будет напечатан на экране и сохранён в файл под названием `all.pdb`.

:::::::::::::::  solution

## Решение

Правильный ответ — 3. Оператор `>>` добавляет данные в файл, а не перезаписывает его. Поскольку вывод команды `cat` перенаправляется, на экране ничего не будет напечатано.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Продолжим наш пример в каталоге `shell-lesson-data/exercise-data/creatures`. Вот немного более сложный цикл:

```bash
$ for filename in *.dat
> do
>     echo $filename
>     head -n 100 $filename | tail -n 20
> done
```

Оболочка начинает с расширения `*.dat`, создавая список файлов для обработки. **Тело цикла** затем выполняет две команды для каждого из этих файлов. Первая команда, `echo`, выводит свои аргументы командной строки в стандартный вывод. Например:

```bash
$ echo hello there
```

выведет:

```вывод
hello there
```

В данном случае, поскольку оболочка расширяет `$filename` до имени файла, `echo` `$filename` выводит имя файла. Обратите внимание, что мы не можем записать это так:

```bash
$ for filename in *.dat
> do
>     $filename
>     head -n 100 $filename | tail -n 20
> done
```

потому что тогда при первом прохождении цикла, когда `$filename` расширится до `basilisk.dat`, оболочка попытается запустить `basilisk.dat` как программу. Наконец, комбинация команд `head` и `tail` выбирает строки с 81 по 100 из любого обрабатываемого файла (предполагая, что в файле не менее 100 строк).

:::::::::::::::::::::::::::::::::::::::::  callout

## Пробелы в именах

Пробелы используются для разделения элементов списка, по которому мы собираемся пройти в цикле. Если один из этих элементов содержит символ пробела, нам нужно окружить его кавычками, и то же самое сделать с переменной цикла. Предположим, что наши файлы данных называются:

```source
red dragon.dat
purple unicorn.dat
```

Чтобы пройти по этим файлам в цикле, нам нужно добавить двойные кавычки следующим образом:

```bash
$ for filename in "red dragon.dat" "purple unicorn.dat"
> do
>     head -n 100 "$filename" | tail -n 20
> done
```

Проще избегать использования пробелов (или других специальных символов) в именах файлов.

Указанные файлы не существуют, поэтому, если мы запустим приведённый выше код, команда `head` не сможет найти их; однако возвращённое сообщение об ошибке покажет имена файлов, которые она ожидает:

```error
head: cannot open ‘red dragon.dat' for reading: No such file or directory
head: cannot open ‘purple unicorn.dat' for reading: No such file or directory
```

Попробуйте убрать кавычки вокруг `$filename` в приведённом выше цикле, чтобы увидеть, как кавычки влияют на пробелы. Обратите внимание, что при выполнении кода в каталоге `creatures` мы получаем результат для файла `unicorn.dat`:

```вывод
head: cannot open ‘red' for reading: No such file or directory
head: cannot open ‘dragon.dat' for reading: No such file or directory
head: cannot open ‘purple' for reading: No such file or directory
CGGTACCGAA
AAGGGTCGCG
CAAGTGTTCC
...
```

::::::::::::::::::::::::::::::::::::::::::::::::::

Мы хотим изменить каждый файл в каталоге `shell-lesson-data/exercise-data/creatures`, но при этом сохранить версию исходных файлов. Мы хотим скопировать исходные файлы в новые с именами, такими как `original-basilisk.dat` и `original-unicorn.dat`. Мы не можем использовать:

```bash
$ cp *.dat original-*.dat
```

потому что это расширится до:

```bash
$ cp basilisk.dat minotaur.dat unicorn.dat original-*.dat
```

Команда не создаст резервные копии файлов, вместо этого мы получим ошибку:

```error
cp: target `original-*.dat' is not a directory
```

Эта проблема возникает, когда `cp` получает более двух входных аргументов. В этом случае он ожидает, что последний аргумент будет каталогом, куда можно скопировать все переданные ему файлы. Поскольку в каталоге `creatures` нет каталога с именем `original-*.dat`, возникает ошибка.

Вместо этого можно использовать цикл:

```bash
$ for filename in *.dat
> do
>     cp $filename original-$filename
> done
```

Этот цикл выполняет команду `cp` один раз для каждого имени файла. В первый раз, когда `$filename` разворачивается до `basilisk.dat`, оболочка выполняет:

```bash
cp basilisk.dat original-basilisk.dat
```

Во второй раз команда будет такой:

```bash
cp minotaur.dat original-minotaur.dat
```

В третий и последний раз команда будет такой:

```bash
cp unicorn.dat original-unicorn.dat
```

Поскольку команда `cp` обычно не выводит ничего на экран, сложно проверить, что цикл работает правильно. Однако, как мы узнали ранее, можно использовать команду `echo` для вывода строк, и мы можем изменить цикл, чтобы он выводил наши команды без их фактического выполнения. Таким образом, мы можем проверить, какие команды будут выполнены в неизменённом цикле.

Следующая схема показывает, что происходит, когда модифицированный цикл выполняется, и демонстрирует, как разумное использование echo является хорошей техникой отладки.

![Цикл for "for filename in .dat; do echo cp $filename original-$filename; done" последовательно присваивает переменной "$filename" имена всех файлов ".dat" в текущем каталоге и выполняет команду. С файлами "basilisk.dat", "minotaur.dat" и "unicorn.dat" в текущем каталоге цикл последовательно вызовет команду echo трижды и выведет три строки: "cp basilisk.dat original-basilisk.dat", затем "cp minotaur.dat original-minotaur.dat" и наконец "cp unicorn.dat original-unicorn.dat"](fig/shell_script_for_loop_flow_chart.svg)

## Конвейер Нелли: обработка файлов

Теперь Нелли готова обработать свои файлы данных с помощью `goostats.sh` — скрипта оболочки, написанного её руководителем. Этот скрипт вычисляет некоторые статистические данные из файла с образцом белка и принимает два аргумента:

1. входной файл (содержащий сырые данные)
2. выходной файл (для хранения вычисленных статистических данных)

Так как она всё ещё учится работать с оболочкой, она решает поэтапно настраивать команды, которые ей нужно выполнить. Её первый шаг — убедиться, что она может выбрать правильные входные файлы — помните, это те файлы, чьи имена заканчиваются на 'A' или 'B', а не на 'Z'. Перейдя в каталог `north-pacific-gyre`, Нелли вводит:

```bash
$ cd
$ cd Desktop/shell-lesson-data/north-pacific-gyre
$ for datafile in NENE*A.txt NENE*B.txt
> do
>     echo $datafile
> done
```

```вывод
NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...
NENE02043A.txt
NENE02043B.txt
```

Следующим её шагом будет решение о том, как назвать файлы, которые создаст программа анализа `goostats.sh`. Добавление префикса к имени каждого входного файла словом `stats` кажется простым решением, поэтому она изменяет свой цикл следующим образом:

```bash
$ for datafile in NENE*A.txt NENE*B.txt
> do
>     echo $datafile stats-$datafile
> done
```

```вывод
NENE01729A.txt stats-NENE01729A.txt
NENE01729B.txt stats-NENE01729B.txt
NENE01736A.txt stats-NENE01736A.txt
...
NENE02043A.txt stats-NENE02043A.txt
NENE02043B.txt stats-NENE02043B.txt
```

Она ещё не запускала `goostats.sh`, но теперь уверена, что сможет выбрать правильные файлы и сгенерировать правильные имена выходных файлов.

Постоянный ввод команд становится утомительным, и Нелли беспокоится о том, что может допустить ошибку, поэтому, вместо того чтобы снова вводить цикл, она нажимает <kbd>↑</kbd>. В ответ оболочка выводит весь цикл на одной строке (с использованием точек с запятой для разделения частей):

```bash
$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done
```

Используя клавишу <kbd>←</kbd>, Нелли переходит к команде `echo` и изменяет её на `bash goostats.sh`:

```bash
$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done
```

Когда она нажимает <kbd>Enter</kbd>, оболочка выполняет модифицированную команду. Однако ничего не происходит — на экране нет вывода. Через мгновение Нелли понимает, что, так как её скрипт больше ничего не выводит на экран, она не знает, выполняется ли он вообще, и насколько быстро. Она завершает выполнение команды, набрав <kbd>Ctrl</kbd>+<kbd>C</kbd>, использует <kbd>↑</kbd> для повторного ввода команды и редактирует её, чтобы она выглядела так:

```bash
$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;
bash goostats.sh $datafile stats-$datafile; done
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Начало и конец строки

Мы можем перемещаться к началу строки в оболочке, набрав <kbd>Ctrl</kbd>+<kbd>A</kbd>, и к концу строки, используя <kbd>Ctrl</kbd>+<kbd>E</kbd>.

::::::::::::::::::::::::::::::::::::::::::::::::::

Теперь при выполнении программы выводится одна строка каждые пять секунд:

```вывод
NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...
```

1518 умножить на 5 секунд, разделить на 60 — это означает, что её скрипт будет выполняться около двух часов. В качестве последней проверки она открывает другое окно терминала, заходит в каталог `north-pacific-gyre` и использует команду `cat stats-NENE01729B.txt`, чтобы проверить один из выходных файлов. Всё выглядит хорошо, так что она решает пойти выпить кофе и почитать.

:::::::::::::::::::::::::::::::::::::::::  callout

## Те кто помнят прошлое, могут повторить его в будущем

Ещё один способ повторить предыдущую работу — это использовать команду `history` для получения списка последних нескольких сотен выполненных команд и затем использовать `!123` (где '123' заменяется номером команды), чтобы повторить одну из этих команд. Например, если Нелли вводит следующее:

```bash
$ history | tail -n 5
```

```вывод
456  for datafile in NENE*A.txt NENE*B.txt; do   echo $datafile stats-$datafile; done
457  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done
458  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done
459  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile
stats-$datafile; done
460  history | tail -n 5
```

она может снова запустить `goostats.sh` для файлов, просто введя `!459`.


::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## Другие команды истории

Существует несколько других команд для работы с историей.

- <kbd>Ctrl</kbd>+<kbd>R</kbd> запускает режим поиска по истории 'reverse-i-search' и находит самую последнюю команду в вашей истории, соответствующую введённому тексту. Нажмите <kbd>Ctrl</kbd>+<kbd>R</kbd> ещё раз (или несколько раз), чтобы найти более ранние совпадения. Затем можно использовать клавиши со стрелками влево и вправо, чтобы выбрать эту строку, отредактировать её и нажать <kbd>Return</kbd> для выполнения команды.
- `!!` выводит предыдущую команду (возможно, вы найдёте это более удобным, чем использование <kbd>↑</kbd>).
- `!$` выводит последнее слово предыдущей команды. Это может быть полезно чаще, чем вы думаете: после выполнения команды `bash goostats.sh NENE01729B.txt stats-NENE01729B.txt` вы можете ввести `less !$`, чтобы просмотреть файл `stats-NENE01729B.txt`, что быстрее, чем использовать <kbd>↑</kbd> и редактировать командную строку.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Пробный запуск

Цикл позволяет выполнять множество действий сразу — или допустить множество ошибок, если он выполняет что-то неправильно. Один из способов проверить, что _сделает_ цикл — это вывести команды, которые он бы запустил, вместо их фактического выполнения с помощью echo.

Предположим, мы хотим предварительно просмотреть команды, которые выполнит следующий цикл, не запуская их:

```bash
$ for datafile in *.pdb
> do
>     cat $datafile >> all.pdb
> done
```

В чём разница между двумя циклами ниже, и какой из них мы бы хотели запустить?

```bash
# Version 1
$ for datafile in *.pdb
> do
>     echo cat $datafile >> all.pdb
> done
```

```bash
# Version 2
$ for datafile in *.pdb
> do
>     echo "cat $datafile >> all.pdb"
> done
```

:::::::::::::::  solution

## Решение

Вторая версия — та, которую мы хотим запустить. Она выводит на экран всё, что заключено в кавычки, расширяя переменную цикла, так как мы поставили перед ней знак доллара. При этом не создаётся и не изменяется файл `all.pdb`, так как `>>` воспринимается буквально как часть строки, а не как инструкция перенаправления.

Первая версия добавляет вывод команды `echo cat $datafile` в файл `all.pdb`. Этот файл будет содержать только список команд: `cat cubane.pdb`, `cat ethane.pdb`, `cat methane.pdb` и т.д.

Попробуйте обе версии самостоятельно, чтобы увидеть результат! Не забудьте открыть файл `all.pdb`, чтобы посмотреть его содержимое.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Вложенные циклы

Предположим, что мы хотим создать структуру каталогов для организации экспериментов, измеряющих константы скорости реакции с разными соединениями и при разных температурах. Каков будет результат выполнения следующего кода:

```bash
$ for species in cubane ethane methane
> do
>     for temperature in 25 30 37 40
>     do
>         mkdir $species-$temperature
>     done
> done
```

:::::::::::::::  solution

## Решение

Мы имеем дело с вложенным циклом, то есть цикл находится внутри другого цикла. Поэтому для каждого вещества во внешнем цикле, внутренний цикл (вложенный цикл) проходит по списку температур и создаёт новый каталог для каждой комбинации.

Попробуйте запустить этот код самостоятельно, чтобы увидеть, какие каталоги будут созданы!

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- Цикл `for` повторяет команды для каждого элемента списка.
- Каждый цикл `for` требует переменную, чтобы ссылаться на элемент, с которым он в данный момент работает.
- Используйте `$name`, чтобы развернуть переменную (то есть получить её значение). Можно также использовать `${name}`.
- Не используйте пробелы, кавычки или символы подстановки, такие как '*' или '?' в именах файлов, так как это усложняет развёртывание переменных.
- Давайте файлам последовательные имена, которые легко сопоставить с шаблонами подстановки, чтобы было проще выбирать их для циклов.
- Используйте клавишу со стрелкой вверх, чтобы пролистать предыдущие команды и повторить их с изменениями.
- Используйте <kbd>Ctrl</kbd>+<kbd>R</kbd>, чтобы искать ранее введённые команды.
- Используйте команду `history` для отображения последних команд и `![number]`, чтобы повторить команду по её номеру.

::::::::::::::::::::::::::::::::::::::::::::::::::
