---
title: Работа с файлами и каталогами
teaching: 30
exercises: 20
---

::::::::::::::::::::::::::::::::::::::: objectives

- Создать иерархию каталогов, соответствующую заданной схеме.
- Создать файлы в этой иерархии с помощью редактора или путем копирования и переименования существующих файлов.
- Удалить, скопировать и переместить указанные файлы и/или каталоги.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Как я могу создать, скопировать и удалить файлы и каталоги?
- Как я могу редактировать файлы?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Создание каталогов

Теперь мы знаем, как исследовать файлы и каталоги, но как их создать?

В этом разделе мы узнаем, как создавать и перемещать файлы и каталоги, используя каталог `exercise-data/writing` в качестве примера.

### Шаг первый: проверим, где мы находимся и что у нас уже есть

Мы всё ещё должны находиться в каталоге `shell-lesson-data`, расположенном на рабочем столе, в чём можно убедиться с помощью:

```bash
$ pwd
```

```output
/Users/nelle/Desktop/shell-lesson-data
```

Далее перейдём в каталог `exercise-data/writing` и посмотрим, что в нём содержится:

```bash
$ cd exercise-data/writing/
$ ls -F
```

```output
haiku.txt  LittleWomen.txt
```

### Создание каталога

Создадим новый каталог под названием `thesis`, используя команду `mkdir thesis` (которая не выведет никакого результата):

```bash
$ mkdir thesis
```

Как можно догадаться по названию, `mkdir` означает '**m**a**k**e **dir**ectory ('создать каталог'). Так как `thesis` — это относительный путь (т.е. не имеет ведущего слэша, как в `/what/ever/thesis`), новый каталог создаётся в текущем рабочем каталоге:

```bash
$ ls -F
```

```output
haiku.txt  LittleWomen.txt  thesis/
```

Поскольку мы только что создали каталог `thesis`, в нём пока ничего нет:

```bash
$ ls -F thesis
```

Обратите внимание, что `mkdir` не ограничивается созданием одного каталога за раз. Опция -p позволяет `mkdir` создать каталог с вложенными подкаталогами за одну операцию:

```bash
$ mkdir -p ../project/data ../project/results
```

Опция `-R` для команды `ls` выведет все вложенные подкаталоги внутри каталога. Давайте используем команду `ls -FR`, чтобы рекурсивно вывести новую иерархию каталогов, которую мы только что создали в каталоге `project`:

```bash
$ ls -FR ../project
```

```output
../project/:
data/  results/

../project/data:

../project/results:
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Два способа сделать одно и то же

Использование оболочки для создания каталога ничем не отличается от использования файлового менеджера. Если вы откроете текущий каталог с помощью графического файлового менеджера вашей операционной системы, каталог `thesis` также появится там. Хотя оболочка и файловый менеджер — это два разных способа взаимодействия с файлами, сами файлы и каталоги остаются одними и теми же.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## Хорошие имена для файлов и каталогов

Сложные имена файлов и каталогов могут сильно усложнить вашу работу в командной строке. Вот несколько полезных советов по именованию файлов и каталогов.

1. Не используйте пробелы.

Пробелы могут делать имена более понятными, но так как пробелы используются для разделения аргументов в командной строке, лучше избегать их в именах файлов и каталогов. Вместо этого можно использовать `-` или `_` (например, `north-pacific-gyre/` вместо `north pacific gyre/`). Попробуйте ввести `mkdir north pacific gyre` и посмотрите, какой каталог (а точнее, каталоги!) будут созданы, когда вы проверите результат командой `ls -F`.

2. Не начинайте имя с дефиса (символа `-`).

Команды интерпретируют имена, начинающиеся с -, как опции команды.

3. Ограничьтесь использованием букв, цифр и символов `.`, `-` и `_`.

Многие другие символы имеют особые значения в командной строке. Мы изучим некоторые из них в этом уроке. Существуют специальные символы, которые могут привести к тому, что ваша команда не сработает так, как ожидалось, и даже могут вызвать потерю данных.

Если вам нужно обратиться к файлам или каталогам с пробелами или другими специальными символами в именах, окружите имя в одинарные [кавычки](https://www.gnu.org/software/bash/manual/html_node/Quoting.html) (`''`).

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  instructor

Учащиеся иногда могут застрять в текстовых редакторах командной строки, таких как Vim, Emacs или Nano. Закрытие и повторное открытие терминала может быть удручающим, так как им придется снова переходить в нужную папку. Мы рекомендуем инструкторам использовать тот же текстовый редактор, что и учащиеся, во время занятий (в большинстве случаев Nano).

::::::::::::::::::::::::::::::::::::::::::::::::::

### Создание текстового файла

Давайте изменим наш рабочий каталог на `thesis`, используя команду `cd`, а затем запустим текстовый редактор под названием Nano, чтобы создать файл с именем `draft.txt`:

```bash
$ cd thesis
$ nano draft.txt
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Какой редактор?

Когда мы говорим, что nano — это текстовый редактор, мы действительно имеем в виду именно "текстовый". Он может работать только с текстовыми данными, а не с таблицами, изображениями или другими типами медиа. Мы используем его в примерах, потому что это один из самых простых текстовых редакторов. Однако из-за этой простоты он может оказаться недостаточно мощным или гибким для работы, которую вам нужно будет выполнять после этого урока. На Unix-системах (таких как Linux и macOS) многие программисты используют [Emacs](https://www.gnu.org/software/emacs/) или [Vim](https://www.vim.org/) (оба требуют больше времени для изучения), или графический редактор, такой как [Gedit](https://projects.gnome.org/gedit/) или [VScode](https://code.visualstudio.com/). На Windows вы можете использовать [Notepad++](https://notepad-plus-plus.org/). В Windows также есть встроенный редактор `notepad`, который можно запустить из командной строки так же, как и `nano`, для целей этого урока.

Независимо от того, какой редактор вы используете, вам нужно знать, где он сохраняет файлы. Если вы запускаете его из оболочки, он (вероятно) будет использовать ваш текущий рабочий каталог в качестве места по умолчанию. Если вы используете меню "Пуск" на компьютере, редактор может захотеть сохранить файлы на вашем рабочем столе или в папке "Документы". Это можно изменить, перейдя в другой каталог при первом сохранении файла с помощью команды "Сохранить как...".

::::::::::::::::::::::::::::::::::::::::::::::::::

Давайте наберём несколько строк текста.

![Скриншот работы в текстовом редакторе nano с текстом 'It's not publish or perish any more, it's share and thrive'](fig/nano-screenshot.png)

Когда мы будем довольны нашим текстом, мы можем нажать <kbd>Ctrl</kbd>+<kbd>O</kbd> (удерживая клавишу <kbd>Ctrl</kbd>, нажмите клавишу <kbd>O</kbd>), чтобы записать данные на диск. Нам будет предложено ввести имя файла, в котором будет сохранён текст. Нажмите <kbd>Return</kbd>, чтобы подтвердить предлагаемое имя `draft.txt`.

После того как файл будет сохранён, мы можем использовать <kbd>Ctrl</kbd>+<kbd>X</kbd>, чтобы выйти из редактора и вернуться в оболочку.

:::::::::::::::::::::::::::::::::::::::::  callout

## Клавиша Control (Ctrl или ^)

Клавиша Control также называется клавишей 'Ctrl'. Существует несколько способов обозначить использование клавиши Control. Например, вы можете увидеть инструкцию нажать <kbd>Control</kbd>, удерживая ее, нажать клавишу <kbd>X</kbd>. Это можно обозначить как:

- `Control-X`
- `Control+X`
- `Ctrl-X`
- `Ctrl+X`
- `^X`
- `C-x`

В nano внизу экрана вы увидите `^G Get Help ^O WriteOut`. Это означает, что вы можете использовать `Control-G` для получения справки и `Control-O` для сохранения файла.

::::::::::::::::::::::::::::::::::::::::::::::::::

После выхода, `nano` не выводит какие-либо сообщения на экран, но команда `ls` теперь покажет, что мы создали файл под названием `draft.txt`:

```bash
$ ls
```

```output
draft.txt
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Создание файлов другим способом

Мы уже увидели, как создавать текстовые файлы с помощью редактора `nano`. Теперь попробуйте следующую команду:

```bash
$ touch my_file.txt
```

1. Что делает команда `touch`? Появляется ли файл в вашем текущем каталоге при просмотре через графический файловый менеджер?

2. Используйте `ls -l`, чтобы исследовать файлы. Какого размера файл `my_file.txt`?

3. Когда может быть полезно создать файл таким способом?

:::::::::::::::  solution

## Решение

1. Команда `touch` создает новый файл под названием `my_file.txt` в вашем текущем каталоге. Вы можете увидеть этот созданный файл, набрав команду `ls` в командной строке. Файл `my_file.txt` также будет виден в вашем графическом файловом менеджере.

2. Если вы исследуете файл с помощью команды `ls -l`, то заметите, что размер файла `my_file.txt` равен 0 байтам. Другими словами, он не содержит данных. Если вы откроете файл `my_file.txt` в текстовом редакторе, он будет пуст.

3. Некоторые программы не создают выходные файлы самостоятельно, а требуют, чтобы пустые файлы уже были созданы. Когда программа запускается, она ищет существующий файл, чтобы заполнить его своими данными. Команда `touch` позволяет эффективно создавать пустой текстовый файл, который можно использовать такими программами.

:::::::::::::::::::::::::

Чтобы избежать путаницы в дальнейшем, рекомендуем удалить только что созданный файл перед продолжением урока, иначе дальнейшие выводы могут отличаться от приведённых в примере. Для этого используйте следующую команду:

```bash
$ rm my_file.txt
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::  callout

## Что в имени?

Вы могли заметить, что все файлы Нелли названы по шаблону 'что-то точка что-то', и в этой части урока мы всегда использовали расширение `.txt`. Это всего лишь соглашение; мы можем назвать файл `mythesis` или как угодно иначе. Однако большинство людей используют двухсоставные имена, чтобы помочь себе (и своим программам) различать разные типы файлов. Вторая часть такого имени называется **расширением файла** и указывает на тип данных, которые содержит файл: `.txt` обозначает простой текстовый файл, `.pdf` указывает на PDF-документ, `.cfg` — это файл конфигурации, полный параметров для какой-либо программы, `.png` — это изображение в формате PNG и так далее.

Это всего лишь соглашение, хотя и важное. Файлы содержат только байты; нам и нашим программам предстоит интерпретировать эти байты в соответствии с правилами для текстовых файлов, PDF-документов, конфигурационных файлов, изображений и так далее.

Назвав PNG-изображение кита как `whale.mp3`, вы не превратите его в запись звуков китов, хотя это _может_ привести к тому, что операционная система свяжет файл с музыкальным плеером. В этом случае, если кто-то дважды щёлкнет на `whale.mp3` в файловом менеджере, музыкальный плеер автоматически (и ошибочно) попытается открыть файл `whale.mp3`.

::::::::::::::::::::::::::::::::::::::::::::::::::

## Перемещение файлов и каталогов

Возвращаемся в каталог `shell-lesson-data/exercise-data/writing`:

```bash
$ cd ~/Desktop/shell-lesson-data/exercise-data/writing
```

В нашем каталоге `thesis` есть файл `draft.txt`, который не очень информативно назван, поэтому давайте изменим имя файла с помощью команды `mv`, которая сокращённо означает '**m**o**v**e' (переместить):

```bash
$ mv thesis/draft.txt thesis/quotes.txt
```

Первый аргумент указывает `mv`, что мы перемещаем, а второй — куда. В данном случае мы перемещаем `thesis/draft.txt` в `thesis/quotes.txt`, что фактически равносильно переименованию файла. Как и ожидалось, команда `ls` показывает, что теперь в каталоге `thesis` находится один файл под названием `quotes.txt`:

```bash
$ ls thesis
```

```output
quotes.txt
```

Будьте осторожны при указании имени целевого файла, так как команда `mv` без лишних слов перезапишет любой существующий файл с тем же именем, что может привести к потере данных. По умолчанию `mv` не запрашивает подтверждения перед перезаписью файлов. Однако дополнительная опция, `mv -i` (или `mv --interactive`), заставит команду `mv` запрашивать такое подтверждение.

Обратите внимание, что команда `mv` также работает и с каталогами.

Давайте переместим файл `quotes.txt` в текущий рабочий каталог. Мы снова используем команду `mv`, но на этот раз укажем только имя каталога в качестве второго аргумента, чтобы сообщить `mv`, что мы хотим сохранить имя файла, но поместить файл в новое место. (Именно поэтому команда называется 'move'.) В данном случае каталог, который мы укажем, — это специальный каталог `.`, который мы упоминали ранее.

```bash
$ mv thesis/quotes.txt .
```

В результате этой команды файл переместится из каталога, в котором он находился, в текущий рабочий каталог. Теперь команда `ls` показывает, что каталог `thesis` пуст:

```bash
$ ls thesis
```

```output
$
```

Кроме того, мы можем убедиться, что файл quotes.txt больше не находится в каталоге thesis, пытаясь вывести его с помощью `ls` в явном виде:

```bash
$ ls thesis/quotes.txt
```

```error
ls: cannot access 'thesis/quotes.txt': No such file or directory
```

Команда `ls` с указанием имени файла или каталога в качестве аргумента выводит только запрашиваемый файл или содержимое каталога. Если файл, указанный в аргументе, не существует, оболочка вернёт ошибку, как показано выше. Мы можем использовать это, чтобы убедиться, что файл `quotes.txt` теперь находится в нашем текущем каталоге:

```bash
$ ls quotes.txt
```

```output
quotes.txt
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Перемещение файлов в новую папку

После выполнения следующих команд Джейми понимает, что она поместила файлы `sucrose.dat` и `maltose.dat` не в ту папку. Эти файлы должны были быть помещены в папку `raw`.

```bash
$ ls -F
 analyzed/ raw/
$ ls -F analyzed
fructose.dat glucose.dat maltose.dat sucrose.dat
$ cd analyzed
```

Заполните пропуски, чтобы переместить эти файлы в папку `raw/` (ту, куда Джейми забыла их поместить).

```bash
$ mv sucrose.dat maltose.dat ____/____
```

:::::::::::::::  solution

## Решение

```bash
$ mv sucrose.dat maltose.dat ../raw
```

Напомним, что `..` ссылается на родительский каталог (т.е. на один уровень выше текущего каталога), а `.` ссылается на текущий каталог.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Копирование файлов и каталогов

Команда `cp` работает так же, как и `mv`, за исключением того, что она копирует файл вместо его перемещения. Мы можем проверить, что она сработала правильно, используя команду `ls` с двумя путями в качестве аргументов — как и большинство команд Unix, `ls` может принимать несколько путей сразу:

```bash
$ cp quotes.txt thesis/quotations.txt
$ ls quotes.txt thesis/quotations.txt
```

```output
quotes.txt   thesis/quotations.txt
```

Мы также можем скопировать каталог со всем его содержимым, используя опцию [рекурсии](https://ru.wikipedia.org/wiki/Рекурсия) `-r`, например, для создания резервной копии каталога:

```bash
$ cp -r thesis thesis_backup
```

Мы можем проверить результат, перечислив содержимое обоих каталогов `thesis` и `thesis_backup`:

```bash
$ ls thesis thesis_backup
```

```output
thesis:
quotations.txt

thesis_backup:
quotations.txt
```

Важно включить флаг `-r`. Если вы хотите скопировать каталог и не укажете эту опцию, вы увидите сообщение, что каталог пропущен, потому что `-r` не указано.

``` bash
$ cp thesis thesis_backup
cp: -r not specified; omitting directory 'thesis'
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Переименование файлов

Предположим, вы создали текстовый файл в вашем текущем каталоге, чтобы содержать список статистических тестов, которые вам нужно будет провести для анализа данных, и назвали его `statstics.txt`.

После создания и сохранения файла вы понимаете, что ошиблись в названии! Вы хотите исправить ошибку. Какую из следующих команд можно использовать для этого?

1. `cp statstics.txt statistics.txt`
2. `mv statstics.txt statistics.txt`
3. `mv statstics.txt .`
4. `cp statstics.txt .`

:::::::::::::::  solution

## Решение

1. Нет. Хотя это создаст файл с правильным именем, файл с неправильным именем всё ещё останется в каталоге, и его нужно будет удалить.
2. Да, это сработает для переименования файла.
3. Нет, точка (`.`) указывает, куда переместить файл, но не предоставляет новое имя файла, программа не будет работать, если имя конечного файла совпадает с исходным.
4. Нет, точка (`.`) указывает, куда копировать файл, но не предоставляет новое имя файла, программа не будет работать, если имя конечного файла совпадает с исходным.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Перемещение и копирование

Каков результат выполнения заключительной команды `ls` в приведённой ниже последовательности?

```bash
$ pwd
```

```output
/Users/jamie/data
```

```bash
$ ls
```

```output
proteins.dat
```

```bash
$ mkdir recombined
$ mv proteins.dat recombined/
$ cp recombined/proteins.dat ../proteins-saved.dat
$ ls
```

1. `proteins-saved.dat recombined`
2. `recombined`
3. `proteins.dat recombined`
4. `proteins-saved.dat`

:::::::::::::::  solution

## Решение

Мы начинаем в каталоге `/Users/jamie/data` и создаём новую папку под названием `recombined`. Вторая строка перемещает (`mv`) файл `proteins.dat` в новую папку (`recombined`). Третья строка создаёт копию файла, который мы только что переместили. Сложность здесь заключается в том, куда был скопирован файл. Напомним, что `..` означает 'подняться на уровень выше', поэтому скопированный файл теперь находится в `/Users/jamie`. Обратите внимание, что `..` интерпретируется относительно текущего рабочего каталога, а не относительно местоположения копируемого файла. Таким образом, единственное, что покажет `ls` в каталоге `/Users/jamie/data`, — это папка `recombined`.

1. Нет, см. объяснение выше. `proteins-saved.dat` находится в `/Users/jamie`.
2. Да.
3. Нет, см. объяснение выше. Файл `proteins.dat` находится в `/Users/jamie/data/recombined`.
4. Нет, см. объяснение выше. `proteins-saved.dat` находится в `/Users/jamie`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Удаление файлов и каталогов

Возвращаемся в каталог `shell-lesson-data/exercise-data/writing`. Давайте приведём этот каталог в порядок, удалив файл `quotes.txt`, который мы создали. Команда Unix, которую мы будем использовать для этого, — это `rm` (сокращение от '**r**e**m**ove' — удалить):

```bash
$ rm quotes.txt
```

Мы можем проверить, что файл был удалён, с помощью команды ls:

```bash
$ ls quotes.txt
```

```error
ls: cannot access 'quotes.txt': No such file or directory
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Удаление безвозвратно

В Unix-оболочке нет корзины, из которой можно было бы восстановить удалённые файлы (хотя большинство графических интерфейсов для Unix её имеют). Вместо этого, когда мы удаляем файлы, они отвязываются от файловой системы, чтобы их место на диске можно было перераспределить. Существуют инструменты для поиска и восстановления удалённых файлов, но нет никакой гарантии, что они сработают в каждом конкретном случае, так как компьютер может сразу перераспределить место на диске, где был файл.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Безопасное использование `rm`

Что произойдёт, когда мы выполним команду `rm -i thesis_backup/quotations.txt`? Зачем может понадобиться эта защита при использовании `rm`?

:::::::::::::::  solution

## Решение

```output
rm: remove regular file 'thesis_backup/quotations.txt'? y
```

Опция `-i` перед каждым удалением запрашивает подтверждение (используйте <kbd>Y</kbd>, чтобы подтвердить удаление, или <kbd>N</kbd>, чтобы сохранить файл). Поскольку в Unix-оболочке нет корзины, все удалённые файлы исчезают навсегда. Используя опцию `-i`, у нас есть шанс проверить, удаляем ли мы только те файлы, которые действительно хотим удалить.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Если мы попробуем удалить каталог `thesis` с помощью команды `rm thesis`, то получим сообщение об ошибке:

```bash
$ rm thesis
```

```error
rm: cannot remove 'thesis': Is a directory
```

Это происходит потому, что по умолчанию команда `rm` работает только с файлами, а не с каталогами.

Команда `rm` может удалить каталог _вместе со всем его содержимым_, если мы используем опцию рекурсии `-r`, и сделает это _без запросов подтверждения_:

```bash
$ rm -r thesis
```

Учитывая, что в оболочке нет возможности восстановить удалённые файлы, команду `rm -r` нужно использовать с большой осторожностью (можно рассмотреть вариант использования интерактивной опции `rm -r -i`).

## Операции с несколькими файлами и каталогами

Часто возникает необходимость скопировать или переместить сразу несколько файлов. Это можно сделать, указав список отдельных имён файлов или задать шаблон с использованием символов подстановки. Подстановочные символы — это специальные символы, которые можно использовать для обозначения неизвестных символов или наборов символов при работе с файловой системой Unix.

:::::::::::::::::::::::::::::::::::::::  challenge

## Копирование нескольких файлов

Для этого упражнения можно протестировать команды в каталоге `shell-lesson-data/exercise-data`.

В приведённом ниже примере, что делает команда `cp`, когда ей передают несколько имён файлов и имя каталога?

```bash
$ mkdir backup
$ cp creatures/minotaur.dat creatures/unicorn.dat backup/
```

В следующем примере, что делает команда `cp`, когда ей передают три или более имён файлов?

```bash
$ cd creatures
$ ls -F
```

```output
basilisk.dat  minotaur.dat  unicorn.dat
```

```bash
$ cp minotaur.dat unicorn.dat basilisk.dat
```

:::::::::::::::  solution

## Решение

Если команде `cp` передаются несколько имён файлов, а затем имя каталога (т.е. каталог назначения должен быть последним аргументом), `cp` копирует файлы в указанный каталог.

Если команде передать три имени файлов, она выдаст ошибку, как показано ниже, потому что команда ожидает последним аргументом имя каталога.

```error
cp: target 'basilisk.dat' is not a directory
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Использование подстановочных символов для работы с несколькими файлами одновременно

:::::::::::::::::::::::::::::::::::::::::  callout

## Подстановочные символы

`*` — это **подстановочный символ** (**wildcard**), который представляет **ноль или более** других символов. Рассмотрим каталог `shell-lesson-data/exercise-data/alkanes`: `*.pdb` обозначает `ethane.pdb`, `propane.pdb` и любой файл, который оканчивается на `.pdb`. С другой стороны, `p*.pdb` обозначает только `pentane.pdb` и `propane.pdb`, так как символ 'p' в начале может представлять только те имена файлов, которые начинаются с буквы 'p'.

`?` также является подстановочным символом, но он обозначает **ровно один** символ. Таким образом, `?ethane.pdb` может обозначать `methane.pdb`, в то время как `*ethane.pdb` обозначает и `ethane.pdb`, и `methane.pdb`.

Подстановочные символы могут использоваться в сочетании друг с другом. Например, `???ane.pdb` указывает три любых символа, за которыми следует `ane.pdb`, что даёт `cubane.pdb`, `ethane.pdb`, `octane.pdb`.

Когда оболочка видит подстановочный символ, она разворачивает его в список совпадающих имён файлов до выполнения команды. Исключением является случай, когда выражение с подстановочными символами не соответствует ни одному файлу: в этом случае Bash передаёт выражение как аргумент команды без изменений. Например, если ввести `ls *.pdf` в каталоге `alkanes` (где содержатся только файлы с именами, оканчивающимися на `.pdb`), то вы получите сообщение с ошибкой о том, что файл с именем `*.pdf` не найден. Однако обычно команды, такие как `wc` и `ls`, видят списки имён файлов, соответствующих этим выражениям, но не видят сами подстановочные символы. Разворачивает подстановочные символы именно оболочка, а не другие программы.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Список имён файлов, соответствующих шаблону

Какая команда `ls`, запущенная в каталоге `alkanes`, выведет следующий результат?

`ethane.pdb   methane.pdb`

1. `ls *t*ane.pdb`
2. `ls *t?ne.*`
3. `ls *t??ne.pdb`
4. `ls ethane.*`

:::::::::::::::  solution

## Решение

Решением является вариант №3.

1. Выводит все файлы, имена которых содержат ноль или более символов (`*`), за которыми следует буква `t`, затем ноль или более символов (`*`), за которыми следует `ane.pdb`. Это даст `ethane.pdb`, `methane.pdb`, `octane.pdb`, `pentane.pdb`.

2. Выводит все файлы, имена которых начинаются с нуля или более символов (`*`), за которыми следует буква `t`, затем один символ (`?`), затем `ne.`, за которыми следуют ноль или более символов (`*`). Это даст `octane.pdb` и `pentane.pdb`, но не совпадёт с именами, оканчивающимися на `thane.pdb`.

3. Исправляет проблему варианта 2, совпадая с двумя символами (`??`) между `t` и `ne`. Это правильное решение.

4. Выводит только файлы, начинающиеся с `ethane.`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Ещё о подстановочных символах

У Сэма есть каталог, содержащий данные калибровки (calibration), наборы данных (dataset) и описания этих наборов (dataset_overview):

```bash
.
├── 2015-10-23-calibration.txt
├── 2015-10-23-dataset1.txt
├── 2015-10-23-dataset2.txt
├── 2015-10-23-dataset_overview.txt
├── 2015-10-26-calibration.txt
├── 2015-10-26-dataset1.txt
├── 2015-10-26-dataset2.txt
├── 2015-10-26-dataset_overview.txt
├── 2015-11-23-calibration.txt
├── 2015-11-23-dataset1.txt
├── 2015-11-23-dataset2.txt
├── 2015-11-23-dataset_overview.txt
├── backup
│   ├── calibration
│   └── datasets
└── send_to_bob
    ├── all_datasets_created_on_a_23rd
    └── all_november_files
```

Перед тем как отправиться в новую экспедицию, Сэм хочет сделать резервную копию данных и отправить некоторые наборы данных своему коллеге Бобу. Сэм использует следующие команды для выполнения задачи:

```bash
$ cp *dataset* backup/datasets
$ cp ____calibration____ backup/calibration
$ cp 2015-____-____ send_to_bob/all_november_files/
$ cp ____ send_to_bob/all_datasets_created_on_a_23rd/
```

Помогите Сэму заполнить пропуски.

Окончательная структура каталогов должна выглядеть так:

```bash
.
├── 2015-10-23-calibration.txt
├── 2015-10-23-dataset1.txt
├── 2015-10-23-dataset2.txt
├── 2015-10-23-dataset_overview.txt
├── 2015-10-26-calibration.txt
├── 2015-10-26-dataset1.txt
├── 2015-10-26-dataset2.txt
├── 2015-10-26-dataset_overview.txt
├── 2015-11-23-calibration.txt
├── 2015-11-23-dataset1.txt
├── 2015-11-23-dataset2.txt
├── 2015-11-23-dataset_overview.txt
├── backup
│   ├── calibration
│   │   ├── 2015-10-23-calibration.txt
│   │   ├── 2015-10-26-calibration.txt
│   │   └── 2015-11-23-calibration.txt
│   └── datasets
│       ├── 2015-10-23-dataset1.txt
│       ├── 2015-10-23-dataset2.txt
│       ├── 2015-10-23-dataset_overview.txt
│       ├── 2015-10-26-dataset1.txt
│       ├── 2015-10-26-dataset2.txt
│       ├── 2015-10-26-dataset_overview.txt
│       ├── 2015-11-23-dataset1.txt
│       ├── 2015-11-23-dataset2.txt
│       └── 2015-11-23-dataset_overview.txt
└── send_to_bob
    ├── all_datasets_created_on_a_23rd
    │   ├── 2015-10-23-dataset1.txt
    │   ├── 2015-10-23-dataset2.txt
    │   ├── 2015-10-23-dataset_overview.txt
    │   ├── 2015-11-23-dataset1.txt
    │   ├── 2015-11-23-dataset2.txt
    │   └── 2015-11-23-dataset_overview.txt
    └── all_november_files
        ├── 2015-11-23-calibration.txt
        ├── 2015-11-23-dataset1.txt
        ├── 2015-11-23-dataset2.txt
        └── 2015-11-23-dataset_overview.txt
```

:::::::::::::::  solution

## Решение

```bash
$ cp *calibration.txt backup/calibration
$ cp 2015-11-* send_to_bob/all_november_files/
$ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Организация каталогов и файлов

Джейми работает над проектом и замечает, что её файлы не очень хорошо организованы:

```bash
$ ls -F
```

```output
analyzed/  fructose.dat    raw/   sucrose.dat
```

Файлы `fructose.dat` и `sucrose.dat` содержат результаты её анализа данных. Какие команды, рассмотренные в этом уроке, она должна выполнить, чтобы получить следующий результат?

```bash
$ ls -F
```

```output
analyzed/   raw/
```

```bash
$ ls analyzed
```

```output
fructose.dat    sucrose.dat
```

:::::::::::::::  solution

## Решение

```bash
mv *.dat analyzed
```

Джейми нужно переместить файлы `fructose.dat` и `sucrose.dat` в каталог `analyzed`. Оболочка развернёт `*.dat`, чтобы совпадать со всеми файлами, заканчивающимися на `.dat` в текущем каталоге. Затем команда `mv` переместит список файлов `.dat` в каталог `analyzed`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Воспроизведение структуры каталогов

Вы начинаете новый эксперимент и хотите дублировать структуру каталогов из предыдущего эксперимента, чтобы добавить новые данные.

Предположим, что предыдущий эксперимент находится в каталоге `2016-05-18`, который содержит папку `data`, которая, в свою очередь, содержит папки с именами `raw` и `processed`, в которых находятся файлы данных. Цель — скопировать структуру каталогов из папки `2016-05-18` в папку `2016-05-20`, чтобы ваша окончательная структура каталогов выглядела так:

```output
2016-05-20/
└── data
   ├── processed
   └── raw
```

Какой из следующих наборов команд позволит достичь этой цели? Что делают остальные команды?

```bash
$ mkdir 2016-05-20
$ mkdir 2016-05-20/data
$ mkdir 2016-05-20/data/processed
$ mkdir 2016-05-20/data/raw
```

```bash
$ mkdir 2016-05-20
$ cd 2016-05-20
$ mkdir data
$ cd data
$ mkdir raw processed
```

```bash
$ mkdir 2016-05-20/data/raw
$ mkdir 2016-05-20/data/processed
```

```bash
$ mkdir -p 2016-05-20/data/raw
$ mkdir -p 2016-05-20/data/processed
```

```bash
$ mkdir 2016-05-20
$ cd 2016-05-20
$ mkdir data
$ mkdir raw processed
```

:::::::::::::::  solution

## Решение

Первые два набора команд достигают цели.

Третий набор команд вызовет ошибку, так как по умолчанию команда `mkdir` не создаёт подкаталоги в несуществующем каталоге: сначала должны быть созданы промежуточные уровни каталогов.

Четвёртый набор команд достигает цели. Напомним, что опция `-p`, за которой следует путь из одного или нескольких каталогов, заставляет `mkdir` создавать все необходимые промежуточные подкаталоги.

Последний набор команд создаст каталоги `raw` и `processed` на том же уровне, что и каталог `data`.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- `cp [старое] [новое]` копирует файл.
- `mkdir [путь]` создаёт новый каталог.
- `mv [старое] [новое]` перемещает (переименовывает) файл или каталог.
- `rm [путь]` удаляет (удаляет) файл.
- `*` соответствует **нулю или более** символам в имени файла, например `*.txt` соответствует всем файлам, заканчивающимся на `.txt`.
- ё соответствует любому **одному** символу в имени файла, например `?.txt` соответствует `a.txt`, но не `any.txt`.
- Использование клавиши Control может быть описано разными способами, включая `Ctrl-X`, `Control-X` и `^X`.
- В оболочке нет корзины: если что-то удалено, оно действительно исчезло навсегда.
- Большинство имён файлов имеют формат `что-то.расширение`. Расширение не обязательно, и оно не гарантирует ничего, но обычно используется для указания типа данных в файле.
- В зависимости от типа вашей работы вам может понадобиться более мощный текстовый редактор, чем Nano.

::::::::::::::::::::::::::::::::::::::::::::::::::
